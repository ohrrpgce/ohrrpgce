########################################################################
# Many of the tests in this script might seem silly. That is okay.
#
# See interactivetest.hss for tests which require user input.
#
# Any time you are preparing to fix an engine bug, consider adding a
# test that demonstrates the bug FIRST before you fix the bug.

include, plotscr.hsd
include, autotest.hsi

########################################################################

define constant(1, default wait)

global variable(100, menu item script global)
global variable(101, timer global)
global variable(102, timer global will become)
global variable(103, battle script sequence)
global variable(104, menu close global)
global variable(105, embedding global)
global variable(106, export global 1)
global variable(107, export global 2)
global variable(5000, global 5000)

#string 0 = error messages
#string 1-9 = temporary misc
#string 10 = error message arg
#string 11 = asserts
#string 95-96 = temp misc
define constant(11, assert expression string)

########################################################################

plotscript, run all tests, begin
  suspend player
  seed random(4444)
  hspeak tests
  string tests
  math tests
  save load tests
  slice tests
  door tests
  inventory tests
  hero tests
  trigger tests
  npc tests
  menu tests
  textbox tests
  enemy tests
  battle tests
  timer tests
  $0="TESTS SUCCEEDED"
  trace(0)
  game over
end

########################################################################

script, w, ticks=default wait, begin
  wait(ticks)
  _checkpoint
end

script, crash, begin
  if(string length(10) >> 0) then(
    $0+"("
    concatenate strings(0, 10)
    $0+")"
  )
  show text box(1)
  trace(0)
  w(25)
  game over
end

script, assert failure, begin
  trace(assert expression string)
  crash
end

########################################################################

script, elseif A, x, begin
  if(x == 0) then( return(1) )
  elseif(x == 1) then( return(2) )
  else( return(3) )
end

script, elseif B, x, begin
  if(x == 0)
  elseif(x == 1) then( return(2) )
end

script, elseif C, x, begin
  if(x == 0)
  elseif(x == 1)
  else( return(3) )
end

script, elseif tests, begin
  $0="elseif tests"
  assert(elseif A(0) == 1)
  assert(elseif A(1) == 2)
  assert(elseif A(2) == 3)
  assert(elseif B(0) == 0)
  assert(elseif B(1) == 2)
  assert(elseif B(2) == 0)
  assert(elseif C(0) == 0)
  assert(elseif C(1) == 0)
  assert(elseif C(2) == 3)
end

########################################################################

script, switch A, x, begin
  return(1)
  switch (x) do(
    case(5) do()
    case(zero)
    case(2) return(100)
            return(101)
    case(7) return(-1)
            while(1) do(continue(2))
            return(-1)
    case(1) return(102)
    case(3, 4, 2)
            return(103)
            break
            return(104)
    case(6, else)
      return(99) 
  )
end

script, switch B, x, begin
  return(1)
  switch(x) do(
    case(5) do()
    case(2) do(
      return(100)
      break
      return(101)
    )
    case(1) return(102)
    case((2+1), 2*2, zero)
      if(x) then(return(103))
      else(return(104))
    else(return(99))
  )
end

script, switch tests, begin
  $0="switch tests"
  assert(switch A(0) == 101)
  assert(switch A(1) == 102)
  assert(switch A(2) == 101)
  assert(switch A(3) == 103)
  assert(switch A(4) == 103)
  assert(switch A(5) == 1)
  assert(switch A(6) == 99)
  assert(switch A(7) == 102)
  assert(switch A(8) == 99)

  assert(switch B(0) == 104)
  assert(switch B(1) == 102)
  assert(switch B(2) == 100)
  assert(switch B(3) == 103)
  assert(switch B(4) == 103)
  assert(switch B(5) == 1)
  assert(switch B(6) == 99)
end

########################################################################

# include a file with UTF-16 encoding
include, "utf16 encoding test.hss"

plotscript, ¿ƒüñÑÿ sÇ®¡ÞΤ ηªɱE, begin
	return (42)
end 

# This really doesn't belong here, but I'm too lazy to find a better place
script, hspeak tests, begin
  variable (Über)
  Über := 12
  for (über, über, über + 4) do ()
  assert(Über == 17)

  # Lowercase form in Latin-1, uppercase not
  variable (Ÿve)
  ÿve := 0

  assert(¿ƒüñÑÿ sÇ®¡ÞΤ ηªɱE == 42)

  assert(that script in the other file == 91)
  
  global 5000 := 99999
  assert(global 5000 == 99999)

  elseif tests
  switch tests
end

########################################################################

script, math tests, begin
  variable(n)
  n := 10
  $0="math tests"
  if(abs(-10) <> n) then(crash)
  if(abs(15) <> n + 5) then(crash)
end

########################################################################

script, inventory tests, begin
  $0="Inventory tests"
  # This tests only the inventory and commands to manipulate it.
  # Far more item tests including some equipment/inventory stuff is in 'equipment tests'

  # Precondition: empty inventory

  assert(get inventory size == 600)
  variable(slot, lastslot)
  for (slot, 0, get inventory size -- 1) do (
    assert(item in slot(slot) == -1)
    assert(item count in slot(slot) == 0)
  )

  # Simple stuff
  get item(item:Boots, 3)
  assert(inventory(item:Boots) == 3)
  assert(item in slot(0) == item:Boots)
  assert(item count in slot(0) == 3)
  get item(item:Boots, 99)
  assert(inventory(item:Boots) == 102)
  delete item(item:Boots)
  assert(inventory(item:Boots) == 101)
  delete item(item:Boots, 101)
  assert(inventory(item:Boots) == 0)

  # test item slot commands

  assert(item in slot(0) == -1)
  assert(item count in slot(0) == 0)
  assert(item in slot(1) == -1)
  assert(item count in slot(1) == 0)

  set item in slot(1, item:Boots)  # used on empty slot, adds one item
  assert(item in slot(1) == item:Boots)
  assert(item count in slot(1) == 1)
  assert(inventory(item:Boots) == 1)
  lastslot := get inventory size -- 1
  set item in slot(lastslot, item:Boots)
  assert(item in slot(lastslot) == item:Boots)
  set item count in slot(lastslot, 99)
  assert(inventory(item:Boots) == 100)

  # check deleteitem deletes in right order
  delete item(item:Boots, 5)
  assert(inventory(item:Boots) == 95)
  assert(item count in slot(1) == 0)
  assert(item count in slot(lastslot) == 95)

  # transmog a stack of items
  set item in slot(lastslot, item:SteelSho)
  assert(item in slot(lastslot) == item:SteelSho)
  assert(item count in slot(lastslot) == 95)
  assert(inventory(item:SteelSho) == 95)
  assert(inventory(item:Boots) == 0)

  # test the two additional ways of deleting items
  set item in slot(lastslot, -1)
  assert(item count in slot(lastslot) == 0)
  set item in slot(2, item:Boots)
  set item count in slot(2, 0)
  assert(item in slot(2) == -1) 

  # leave nothing
  for (slot, 0, get inventory size -- 1) do (
    assert(item in slot(slot) == -1)
  )
end

########################################################################

script, hero tests, begin
  hero party management tests
  # The party now contains heroes 0, 1, 2, 3 in that order
  hero caterpillar tests
  hero exp and levels tests
  hero stat growth test
  hero stat tests
  equipment tests
  hero misc tests
  hero names embed tests
  # The party should continue to be 0, 1, 2, 3
end

## hero commands left to test

## spell lists
#can learn spell (hero,attack)
#forget spell (hero,attack)
#knows spell (hero,attack)
#read spell (hero,list,slot)
#teach spell (hero,attack)
#write spell (hero,list,slot,attack)

## Equipment
#set default weapon (hero,item)

## Stats
#get level MP (who, mp level slot)
#set level MP (who, mp level slot, new value)

## Appearance
#get hero palette (who,type)
#get hero picture (who,type)
#reset hero palette (who,type)
#reset hero picture (who,type)
#set hero palette (who,palette,type)
#set hero picture (who,picture,type)

## Misc
#hero base elemental resist as int (who, element)
#hero total elemental resist as int (who, element)
#set hero base elemental resist (who, element, percent)

script, hero party management tests, begin
  $0="hero party management tests"
  assert(room in active party == 3)
  add hero(hero:Helga)
  add hero(hero:Olaf)
  add hero(hero:Frumpy)
  assert(room in active party == 0)
  assert(hero by rank(0) == hero:Freki)
  assert(hero by rank(1) == hero:Helga)
  assert(hero by rank(2) == hero:Olaf)
  assert(hero by rank(3) == hero:Frumpy)
  # with a full party, hero by rank and hero by slot should returnt he same values
  assert(hero by rank(0) == hero by slot(0))
  assert(hero by rank(1) == hero by slot(1))
  assert(hero by rank(2) == hero by slot(2))
  assert(hero by rank(3) == hero by slot(3))
  # now delete the leader
  delete hero(hero:Freki)
  assert(room in active party == 1)
  assert(hero by rank(0) == 1)
  assert(hero by rank(1) == 2)
  assert(hero by rank(2) == 3)
  assert(hero by rank(3) == -1)
  assert(hero by slot(0) == -1)
  assert(hero by slot(1) == 1)
  assert(hero by slot(2) == 2)
  assert(hero by slot(3) == 3)
  # add a different leader
  add hero(hero:Styrge)
  assert(hero by slot(0) == hero:Styrge)
  # test find hero
  assert(find hero(hero:Freki)  == -1)
  assert(find hero(hero:Helga)  == 1)
  assert(find hero(hero:Olaf)   == 2)
  assert(find hero(hero:Frumpy) == 3)
  assert(find hero(hero:Styrge) == 0)
  # test rank in caterpillar
  assert(rank in caterpillar(hero:Freki)  == -1)
  assert(rank in caterpillar(hero:Helga)  == 1)
  assert(rank in caterpillar(hero:Olaf)   == 2)
  assert(rank in caterpillar(hero:Frumpy) == 3)
  assert(rank in caterpillar(hero:Styrge) == 0)
  # Add a hero to the reserve
  add hero(hero:Kitt)
  assert(room in active party == 0)
  variable(slot)
  slot := find hero(hero:Kitt)
  assert(slot >= 4)
  assert(rank in caterpillar(hero:Kitt) == -1)
  assert(hero by slot(slot) == hero:Kitt) # this command needs to work on reserve slots
  assert(hero by rank(4) == -1) # this command should not work on reserve slots
  # names
  $1="Styrge"
  get hero name(2, 0)
  assert(string compare(1, 2))
  $1="Helga"
  get hero name(2, 1)
  assert(string compare(1, 2))
  $1="Olaf"
  get hero name(2, 2)
  assert(string compare(1, 2))
  $1="Frumpy"
  get hero name(2, 3)
  assert(string compare(1, 2))
  $1="Kitt"
  get hero name(2, find hero(hero:Kitt))
  assert(string compare(1, 2))
  $1="Kittzilla"
  set hero name(1, find hero(hero:Kitt))
  get hero name(2, find hero(hero:Kitt))
  assert(string compare(1, 2))
  # Swapping
  swap out hero(hero:Helga)
  assert(hero by slot(1) == -1)
  assert(find hero(hero:Helga) >= 4)
  swap in hero(hero:Kitt)
  assert(hero by slot(1) == hero:Kitt)
  assert(find hero(hero:Kitt) >> 0 && find hero(hero:Kitt) <= 3)
  swap by position(0, 3) # swap Styrge and Frumpy
  assert(hero by slot(0) == hero:Frumpy)
  assert(hero by slot(3) == hero:Styrge)
  swap by position(3, find hero(hero:Helga)) # swap Styrge and Helga
  assert(hero by slot(3) == hero:Helga)
  assert(find hero(hero:Styrge) >= 4)
  swap by name(hero:Kitt, hero:Styrge)
  assert(hero by slot(1) == hero:Styrge)
  assert(find hero(hero:Kitt) >= 4)
  swap out hero(hero by slot(0)) # swap out frumpy
  assert(hero by slot(0) == -1)
  # restore numeric order
  add hero(hero:Freki) # Freki
  assert(hero by slot(0) == hero:Freki)
  swap by position(1, find hero(hero:Helga))
  assert(hero by slot(1) == hero:Helga)
  swap by position(2, find hero(hero:Olaf))
  assert(hero by slot(2) == hero:Olaf)
  swap by position(3, find hero(hero:Frumpy))
  assert(hero by slot(3) == hero:Frumpy)
end

script, hero names embed tests, begin
  $0="hero names embed tests"

  variable(h0, h1, h2, h3)
  # remember the old party order
  h0 := hero by slot(0)
  h1 := hero by slot(1)
  h2 := hero by slot(2)
  h3 := hero by slot(3)
  
  swap by position(0, find hero(hero:Olaf))
  swap out hero(hero by slot(1))
  swap out hero(hero by slot(2))
  swap out hero(hero by slot(3))

  $1="Olaf,,,"
  $2="Olaf,,,"
  $3="Freki,Helga,Olaf,Frumpy,Styrge"
  hero names embed helper

  swap by position(2, find hero(hero:Olaf))
  $1="Olaf,,,"
  $2=",,Olaf,"
  hero names embed helper

  swap by position(0, find hero(hero:Frumpy))
  $1="Frumpy,Olaf,,"
  $2="Frumpy,,Olaf,"
  hero names embed helper

  swap by position(1, find hero(hero:Olaf))
  swap by position(3, find hero(hero:Frumpy))
  $1="Olaf,Frumpy,,"
  $2=",Olaf,,Frumpy"
  hero names embed helper

  add hero(hero:Olaf)  # slot 1
  $4="Nolaf"
  set hero name(4, 1)
  $1="Olaf,Nolaf,Frumpy,"
  $2="Olaf,Nolaf,,Frumpy"
  hero names embed helper

  swap by position(0, find hero(hero:Frumpy))
  $1="Frumpy,Nolaf,Olaf,"
  $2="Frumpy,Nolaf,,Olaf"
  $3="Freki,Helga,Nolaf,Frumpy,Styrge"
  hero names embed helper

  show no value, w

  # restore old party order
  swap by position(0, 1)  # Nolaf to front
  delete hero(hero:Olaf)
  swap by position(0, find hero(h0))  
  swap by position(1, find hero(h1))
  swap by position(2, find hero(h2))
  swap by position(3, find hero(h3))
  show box names
  advance textbox
end

script, hero names embed helper, begin
  show string(2)
  $4="${C0},${C1},${C2},${C3}"
  expand string(4)
  $5="${P0},${P1},${P2},${P3}"
  expand string(5)
  $6="${H0},${H1},${H2},${H3},${H4}"
  expand string(6)
  assert(string compare(1, 4))
  assert(string compare(2, 5))
  assert(string compare(3, 6))
  show box names
end

script, show box names, begin
  show text box(9)
  w(10)
  show text box(10)
  w(10)
  show text box(11)
  w(10)
end

## Party management
#lock hero (who)
#unlock hero (who)

script, hero caterpillar tests, begin
  variable(i)
  $0="hero caterpillar tests"

  $10="leader, cater=ON"
  do hero cater tests(me)
  
  suspend caterpillar
  for(i, 0, 3) do(
    $10="hero "
    append number(10, i)
    $10=", cater=OFF"
    do hero cater tests(i)
  )
  resume caterpillar
  $10=""

end

script, do hero cater tests, who, begin
  variable(d)
  walk hero to x (who, 8), w
  wait for hero(who)
  assert(hero x(who) == 8)
  walk hero to y(who, 10), w
  wait for hero(who)
  assert(hero y(who) == 10)
  camera follows hero(who)
  walk hero to x(who, 9), w
  wait for hero(who)
  assert(hero x(who) == 9)
  walk hero to y(who, 8), w
  wait for hero(who)
  assert(hero y(who) == 8)
  camera follows hero(0)
  walk hero to x (who, 6), w
  wait for hero(who)
  assert(hero x(who) == 6)
  set hero position(who, 7, 7), w
  assert(hero x(who) == 7)
  assert(hero y(who) == 7)
  walk hero(who, south, 2)
  wait for hero(who), w
  assert(hero y(who) == 9)
  assert(hero direction(who) == south)
  walk hero(who, west, 2)
  wait for hero(who), w
  assert(hero x(who) == 5)
  assert(hero direction(who) == west)
  walk hero(who, north, 1)
  wait for hero(who), w
  assert(hero y(who) == 8)
  assert(hero direction(who) == north)
  walk hero(who, east, 1)
  wait for hero(who), w
  assert(hero x(who) == 6)
  assert(hero direction(who) == east)
  # spin
  for(d, north, west) do(
    set hero direction(who, d), w
    assert(hero direction(who) == d)
  )
  # moonwalk
  for(d, north, west) do(
    walk hero(who, ((d + 2) ,mod, 4))
    set hero direction(who, d)
    wait for hero(who), w
    assert(hero direction(who) == d)
  )
  # walk into wall
  walk hero(who, north, 3) # should only make it 2 tiles
  wait for hero(who)
  assert(hero Y(who) == 6)
  # check walls
  expect hero walls(who, true, false, false, false)
  walk hero(who, west, 1)
  wait for hero(who), w
  walk hero(who, north, 1)
  wait for hero(who), w
  expect hero walls(who, false, true, false, false)
  walk hero(who, north, 2)
  wait for hero(who), w
  walk hero(who, east, 1)
  wait for hero(who), w
  expect hero walls(who, false, false, true, false)
  walk hero(who, east, 5)
  wait for hero(who), w
  expect hero walls(who, true, true, false, false)
  # speed test time!
  set hero speed(who, 2)
  assert(get hero speed(who) == 2)
  walk hero(who, south, 1)
  w(9), assert(hero is walking(who))
  w(1), assert(hero is walking(who) == false)
  set hero speed(who, 4)
  assert(get hero speed(who) == 4)
  walk hero(who, south, 1)
  w(4), assert(hero is walking(who))
  w(1), assert(hero is walking(who) == false)
  set hero speed(who, 5)
  assert(get hero speed(who) == 5)
  walk hero(who, south, 1)
  w(3), assert(hero is walking(who))
  w(1), assert(hero is walking(who) == false)
  set hero speed(who, 10)
  assert(get hero speed(who) == 10)
  walk hero(who, south, 1)
  w(1), assert(hero is walking(who))
  w(1), assert(hero is walking(who) == false)
  set hero speed(who, 20)
  assert(get hero speed(who) == 20)
  walk hero(who, south, 1)
  w(1), assert(hero is walking(who) == false)
  walk hero(who, west, 1), w
  walk hero(who, north, 2), w(2)
  assert(hero x(who) == 10)
  assert(hero y(who) == 6)
  set hero speed(who)
  assert(get hero speed(who) == 4)
  walk hero(who, west, 3)
  wait for hero(who)
  #FIXME: should probably test misaligned walking too
  # frame
  variable(fr)
  for(fr, 1, 8) do(
    set hero frame(who, (fr ,mod, 2))
    assert(hero frame(who) == (fr ,mod, 2))
    w(fr)
  )
  #pixel pos
  variable(px, py)
  px := hero pixel x(who)
  assert(px == 140)
  py := hero pixel y(who)
  assert(py == 120)
  variable(ix, iy)
  for(iy, 0, 5) do(
    for(ix, 0, 5) do(
      put hero(who, 105 + ix, 105 + iy)
      assert(hero pixel x(who) == 105 + ix)
      assert(hero pixel y(who) == 105 + iy)
      w
    )
  )
  put hero(who, px, py), w
end

script, expect hero walls, who, wn, we, ws, ww, begin
  assert(check hero wall(who, north) == wn)
  assert(check hero wall(who, east) == we)
  assert(check hero wall(who, south) == ws)
  assert(check hero wall(who, west) == ww)
end

## caterpillar
#suspend hero walls
#resume hero walls
#set hero frame (who, frame)
#set hero speed (who, speed)
#set hero z (who, z)

script, hero exp and levels tests, begin
  variable(i)
  $0="hero exp and levels tests"
  assert(experience to level(1) == 30)
  assert(experience to level(2) == 71)
  assert(experience to level(3) == 125)
  assert(experience to level(4) == 195)
  assert(experience to level(5) == 284)
  assert(experience to level(6) == 396)
  assert(experience to level(7) == 535)
  assert(experience to level(8) == 707)
  assert(experience to level(9) == 918)
  assert(experience to level(10) == 1176)
  assert(experience to level(11) == 1491)
  assert(experience to level(12) == 1874)
  assert(experience to level(13) == 2339)
  assert(experience to level(14) == 2902)
  assert(experience to level(15) == 3583)
  assert(experience to level(99) == 50183838)
  assert(get hero level(0) == 0)
  # level setting
  for(i, 1, 99) do(
    set hero level(0, i)
    assert(get hero level(0) == i)
    assert(total experience(0) == experience to level(i))
  )
  # level-based spell learning/forgetting
  set hero level(0, 9)
  assert(knows spell (0, 2) == false) # Freki should not have L.10 Wolf at level 9
  set hero level(0, 10)
  assert(knows spell (0, 2) == true) # Freki should learn L.10 Wolf at level 10
  set hero level(0, 0, false)
  assert(get hero level(0) == 0)
  assert(hero levelled(0) == -10)
  assert(knows spell (0, 2) == true) # Freki should not forget L.10 Wolf because of how we deleveled
  update level up learning(0, true)
  assert(knows spell (0, 2) == false) # Now Freki should forget L.10 Wolf.
  # experience
  assert(experience to next level(0) == 30)
  give experience(0, 5)
  assert(hero levelled(0) == 0)
  assert(experience to next level(0) == 25)
  give experience(0, 25)
  assert(get hero level(0) == 1)
  assert(hero levelled(0) == 1)
  assert(experience to next level(0) == 41)
  give experience(0, -1) # de-level should not work with this command, but experience will go down
  assert(get hero level(0) == 1)
  assert(hero levelled(0) == 0)
  assert(experience to next level(0) == 42)
  give experience(0, 42)
  assert(get hero level(0) == 2)
  assert(hero levelled(0) == 1)
  set hero level(0, 9)
  give experience(0, experience to next level(0))
  assert(get hero level(0) == 10)
  assert(hero levelled(0) == 1)
  assert(spells learned(0, get count) == 1)
  assert(spells learned(0, 0) == 2)
  assert(spells learnt(0, 0) == 1) #deprecated, but why not test it?
  give experience(0, 1) # should not cause levelling
  assert(hero levelled == 0)
  assert(spells learned(0, get count) == 0)
  # split experience
  set hero level(0, 0, true)
  give experience(party, 30)
  assert(hero levelled(0) == 0)
  assert(total experience(0) == 8)
  assert(total experience(1) == 8)
  assert(total experience(2) == 8)
  assert(total experience(3) == 8)
  give experience(party, 88)
  assert(get hero level(0) == 1)
  assert(get hero level(1) == 1)
  assert(get hero level(2) == 1)
  assert(get hero level(3) == 1)
  assert(total experience(find hero(hero:Kitt)) == 0) # outside of the party
  # experience for dead heroes
  set hero level(0, 0, true)
  set hero level(1, 0, true)
  set hero level(2, 0, true)
  set hero level(3, 0, true)
  set hero stat(2, 0, 0) # kill Olaf
  set dead heroes gain experience (false)
  give experience(party, 120)
  assert(total experience(0) == 40)
  assert(total experience(1) == 40)
  assert(total experience(2) == 0)
  assert(total experience(3) == 40)
  set hero level(0, 0, true)
  set hero level(1, 0, true)
  set hero level(2, 0, true)
  set hero level(3, 0, true)
  set dead heroes gain experience (true)
  give experience(party, 120)
  assert(total experience(0) == 30)
  assert(total experience(1) == 30)
  assert(total experience(2) == 30)
  assert(total experience(3) == 30)
  set hero level(0, 0, true)
  set hero level(1, 0, true)
  set hero level(2, 0, true)
  set hero level(3, 0, true)
  set hero stat(2, 0, get hero stat(2, 0, maximum stat)) # revive Olaf
  # level caps
  set hero level(0, 1)
  assert(get level cap == 99)
  set level cap(2)
  assert(get level cap == 2)
  give experience(0, 41)
  assert(get hero level(0) == 2)
  assert(total experience(0) == 71)
  assert(experience to next level(0) == 54) # being at the level cap does not alter the exp to next level
  give experience(0, 10000000)
  assert(hero levelled(0) == 0)
  assert(get hero level(0) == 2)
  set level cap(99)
  # reset
  set hero level(0, 0, true)
  set hero level(1, 0, true)
  set hero level(2, 0, true)
  set hero level(3, 0, true)
end

script, hero stat growth test, begin
  $0="hero stat growth test"
  show string(0), w
  # This tests the crappy default stat growth curve, which we will hopefully replace someday
  set hero level(0 ,0)
  assert(get hero stat(0, 0, maximum stat) == 10)
  set hero level(0 ,1)
  assert(get hero stat(0, 0, maximum stat) == 13)
  set hero level(0 ,2)
  assert(get hero stat(0, 0, maximum stat) == 16)
#  set hero level(0 ,3)
#  assert(get hero stat(0, 0, maximum stat) == 19)
#  set hero level(0 ,4)
#  assert(get hero stat(0, 0, maximum stat) == 23)
#  set hero level(0 ,5)
#  assert(get hero stat(0, 0, maximum stat) == 26)
#  set hero level(0 ,6)
#  assert(get hero stat(0, 0, maximum stat) == 30)
#  set hero level(0 ,7)
#  assert(get hero stat(0, 0, maximum stat) == 34)
#  set hero level(0 ,8)
#  assert(get hero stat(0, 0, maximum stat) == 38)
#  set hero level(0 ,9)
#  assert(get hero stat(0, 0, maximum stat) == 42)
  set hero level(0 ,10)
  assert(get hero stat(0, 0, maximum stat) == 46)
#  set hero level(0 ,11)
#  assert(get hero stat(0, 0, maximum stat) == 50)
#  set hero level(0 ,12)
#  assert(get hero stat(0, 0, maximum stat) == 55)
#  set hero level(0 ,13)
#  assert(get hero stat(0, 0, maximum stat) == 60)
#  set hero level(0 ,14)
#  assert(get hero stat(0, 0, maximum stat) == 64)
#  set hero level(0 ,15)
#  assert(get hero stat(0, 0, maximum stat) == 69)
#  set hero level(0 ,16)
#  assert(get hero stat(0, 0, maximum stat) == 75)
#  set hero level(0 ,17)
#  assert(get hero stat(0, 0, maximum stat) == 80)
#  set hero level(0 ,18)
#  assert(get hero stat(0, 0, maximum stat) == 85)
#  set hero level(0 ,19)
#  assert(get hero stat(0, 0, maximum stat) == 91)
  set hero level(0 ,20)
  assert(get hero stat(0, 0, maximum stat) == 96)
#  set hero level(0 ,21)
#  assert(get hero stat(0, 0, maximum stat) == 102)
#  set hero level(0 ,22)
#  assert(get hero stat(0, 0, maximum stat) == 108)
#  set hero level(0 ,23)
#  assert(get hero stat(0, 0, maximum stat) == 114)
#  set hero level(0 ,24)
#  assert(get hero stat(0, 0, maximum stat) == 121)
#  set hero level(0 ,25)
#  assert(get hero stat(0, 0, maximum stat) == 127)
#  set hero level(0 ,26)
#  assert(get hero stat(0, 0, maximum stat) == 134)
#  set hero level(0 ,27)
#  assert(get hero stat(0, 0, maximum stat) == 140)
#  set hero level(0 ,28)
#  assert(get hero stat(0, 0, maximum stat) == 147)
#  set hero level(0 ,29)
#  assert(get hero stat(0, 0, maximum stat) == 154)
  set hero level(0 ,30)
  assert(get hero stat(0, 0, maximum stat) == 161)
#  set hero level(0 ,31)
#  assert(get hero stat(0, 0, maximum stat) == 168)
#  set hero level(0 ,32)
#  assert(get hero stat(0, 0, maximum stat) == 176)
#  set hero level(0 ,33)
#  assert(get hero stat(0, 0, maximum stat) == 183)
#  set hero level(0 ,34)
#  assert(get hero stat(0, 0, maximum stat) == 191)
#  set hero level(0 ,35)
#  assert(get hero stat(0, 0, maximum stat) == 199)
#  set hero level(0 ,36)
#  assert(get hero stat(0, 0, maximum stat) == 207)
#  set hero level(0 ,37)
#  assert(get hero stat(0, 0, maximum stat) == 215)
#  set hero level(0 ,38)
#  assert(get hero stat(0, 0, maximum stat) == 223)
#  set hero level(0 ,39)
#  assert(get hero stat(0, 0, maximum stat) == 232)
  set hero level(0 ,40)
  assert(get hero stat(0, 0, maximum stat) == 240)
#  set hero level(0 ,41)
#  assert(get hero stat(0, 0, maximum stat) == 249)
#  set hero level(0 ,42)
#  assert(get hero stat(0, 0, maximum stat) == 258)
#  set hero level(0 ,43)
#  assert(get hero stat(0, 0, maximum stat) == 267)
#  set hero level(0 ,44)
#  assert(get hero stat(0, 0, maximum stat) == 276)
#  set hero level(0 ,45)
#  assert(get hero stat(0, 0, maximum stat) == 285)
#  set hero level(0 ,46)
#  assert(get hero stat(0, 0, maximum stat) == 295)
#  set hero level(0 ,47)
#  assert(get hero stat(0, 0, maximum stat) == 304)
#  set hero level(0 ,48)
#  assert(get hero stat(0, 0, maximum stat) == 314)
#  set hero level(0 ,49)
#  assert(get hero stat(0, 0, maximum stat) == 324)
  set hero level(0 ,50)
  assert(get hero stat(0, 0, maximum stat) == 334)
#  set hero level(0 ,51)
#  assert(get hero stat(0, 0, maximum stat) == 344)
#  set hero level(0 ,52)
#  assert(get hero stat(0, 0, maximum stat) == 354)
#  set hero level(0 ,53)
#  assert(get hero stat(0, 0, maximum stat) == 365)
#  set hero level(0 ,54)
#  assert(get hero stat(0, 0, maximum stat) == 375)
#  set hero level(0 ,55)
#  assert(get hero stat(0, 0, maximum stat) == 386)
#  set hero level(0 ,56)
#  assert(get hero stat(0, 0, maximum stat) == 397)
#  set hero level(0 ,57)
#  assert(get hero stat(0, 0, maximum stat) == 408)
#  set hero level(0 ,58)
#  assert(get hero stat(0, 0, maximum stat) == 419)
#  set hero level(0 ,59)
#  assert(get hero stat(0, 0, maximum stat) == 430)
  set hero level(0 ,60)
  assert(get hero stat(0, 0, maximum stat) == 442)
#  set hero level(0 ,61)
#  assert(get hero stat(0, 0, maximum stat) == 453)
#  set hero level(0 ,62)
#  assert(get hero stat(0, 0, maximum stat) == 465)
#  set hero level(0 ,63)
#  assert(get hero stat(0, 0, maximum stat) == 477)
#  set hero level(0 ,64)
#  assert(get hero stat(0, 0, maximum stat) == 489)
#  set hero level(0 ,65)
#  assert(get hero stat(0, 0, maximum stat) == 501)
#  set hero level(0 ,66)
#  assert(get hero stat(0, 0, maximum stat) == 513)
#  set hero level(0 ,67)
#  assert(get hero stat(0, 0, maximum stat) == 526)
#  set hero level(0 ,68)
#  assert(get hero stat(0, 0, maximum stat) == 538)
#  set hero level(0 ,69)
#  assert(get hero stat(0, 0, maximum stat) == 551)
  set hero level(0 ,70)
  assert(get hero stat(0, 0, maximum stat) == 564)
#  set hero level(0 ,71)
#  assert(get hero stat(0, 0, maximum stat) == 577)
#  set hero level(0 ,72)
#  assert(get hero stat(0, 0, maximum stat) == 590)
#  set hero level(0 ,73)
#  assert(get hero stat(0, 0, maximum stat) == 604)
#  set hero level(0 ,74)
#  assert(get hero stat(0, 0, maximum stat) == 617)
#  set hero level(0 ,75)
#  assert(get hero stat(0, 0, maximum stat) == 631)
#  set hero level(0 ,76)
#  assert(get hero stat(0, 0, maximum stat) == 644)
#  set hero level(0 ,77)
#  assert(get hero stat(0, 0, maximum stat) == 658)
#  set hero level(0 ,78)
#  assert(get hero stat(0, 0, maximum stat) == 672)
#  set hero level(0 ,79)
#  assert(get hero stat(0, 0, maximum stat) == 686)
  set hero level(0 ,80)
  assert(get hero stat(0, 0, maximum stat) == 701)
#  set hero level(0 ,81)
#  assert(get hero stat(0, 0, maximum stat) == 715)
#  set hero level(0 ,82)
#  assert(get hero stat(0, 0, maximum stat) == 730)
#  set hero level(0 ,83)
#  assert(get hero stat(0, 0, maximum stat) == 745)
#  set hero level(0 ,84)
#  assert(get hero stat(0, 0, maximum stat) == 759)
#  set hero level(0 ,85)
#  assert(get hero stat(0, 0, maximum stat) == 774)
#  set hero level(0 ,86)
#  assert(get hero stat(0, 0, maximum stat) == 790)
#  set hero level(0 ,87)
#  assert(get hero stat(0, 0, maximum stat) == 805)
#  set hero level(0 ,88)
#  assert(get hero stat(0, 0, maximum stat) == 820)
#  set hero level(0 ,89)
#  assert(get hero stat(0, 0, maximum stat) == 836)
  set hero level(0 ,90)
  assert(get hero stat(0, 0, maximum stat) == 852)
#  set hero level(0 ,91)
#  assert(get hero stat(0, 0, maximum stat) == 868)
#  set hero level(0 ,92)
#  assert(get hero stat(0, 0, maximum stat) == 884)
#  set hero level(0 ,93)
#  assert(get hero stat(0, 0, maximum stat) == 900)
#  set hero level(0 ,94)
#  assert(get hero stat(0, 0, maximum stat) == 916)
#  set hero level(0 ,95)
#  assert(get hero stat(0, 0, maximum stat) == 933)
#  set hero level(0 ,96)
#  assert(get hero stat(0, 0, maximum stat) == 949)
#  set hero level(0 ,97)
#  assert(get hero stat(0, 0, maximum stat) == 966)
  set hero level(0 ,98)
  assert(get hero stat(0, 0, maximum stat) == 983)
  set hero level(0 ,99)
  assert(get hero stat(0, 0, maximum stat) == 1000)
  set hero level(0, 0, true)
  show no value, w
end

script, restore hp and mp, begin
  variable(i)
  for (i, 0, 40) do (
    if (hero by slot(i) <> -1) then (
      set hero stat(i, stat:hp, get hero stat(i, stat:hp, maximum stat), current stat)
      set hero stat(i, stat:mp, get hero stat(i, stat:mp, maximum stat), current stat)
    )
  )
end

script, hero stat tests, begin
  $0="hero stat tests"
  # test hero stat commands, stat capping, equip stat bonuses, current vs. max quirks, negative stats

  # check initial condition
  assert(hero by slot(1) == hero:Helga)
  assert(get hero level(1) == 0)
  assert(get hero stat(1, stat:hp, current stat) == 10)
  assert(get hero stat(1, stat:mp, current stat) == 20)
  assert(get hero stat(1, stat:atk, current stat) == 10)
  assert(get hero stat(1, stat:spd, current stat) == 30)

  # test stat caps
  assert(get hero stat cap(stat:hp) == 0)
  assert(get hero stat cap(stat:mp) == 0)
  assert(get hero stat cap(stat:atk) == 100)  #in-editor
  assert(get hero stat cap(stat:spd) == 0)
  # set capped hero stat
  set capped hero stat(1, stat:atk, 110, current stat)
  assert(get hero stat(1, stat:atk, current stat) == 100)
  set capped hero stat(1, stat:atk, 120, maximum stat)
  assert(get hero stat(1, stat:atk, maximum stat) == 100)
  set capped hero stat(1, stat:hp, 999999, current stat)
  assert(get hero stat(1, stat:hp, current stat) == 999999)
  set hero stat(1, stat:hp, 10, current stat)  #back to original

  # set hero stat should not be affected by caps
  set hero stat(1, stat:atk, 110, current stat)
  assert(get hero stat(1, stat:atk, current stat) == 110)

  # modify caps  
  set hero stat cap(stat:hp, 5)
  set hero stat cap(stat:mp, 12)
  assert(get hero stat cap(stat:hp) == 5)
  assert(get hero stat(1, stat:hp, current stat) == 5)
  assert(get hero stat(1, stat:hp, maximum stat) == 5)
  assert(get hero stat(1, stat:mp, current stat) == 12)
  assert(get hero stat(1, stat:mp, maximum stat) == 12)
  set hero stat(1, stat:atk, 10, current stat)  #back to original
  set hero stat(1, stat:atk, 10, maximum stat)  #back to original

  set hero stat cap(stat:atk, 0)
  set hero stat cap(stat:spd, 10)
  assert(get hero stat cap(stat:atk) == 0)
  assert(get hero stat cap(stat:spd) == 10)
  assert(get hero stat(1, stat:atk, current stat) == 10)
  assert(get hero stat(1, stat:atk, maximum stat) == 10)
  assert(get hero stat(1, stat:spd, current stat) == 10)
  assert(get hero stat(1, stat:spd, maximum stat) == 10)
  set hero stat cap(stat:hp, 0)
  set hero stat cap(stat:mp, 0)
  set hero stat cap(stat:spd, 0)

  # test original stats restored
  assert(get hero stat(1, stat:hp, maximum stat) == 10)
  assert(get hero stat(1, stat:mp, maximum stat) == 20)
  assert(get hero stat(1, stat:atk, current stat) == 10)
  assert(get hero stat(1, stat:atk, maximum stat) == 10)
  assert(get hero stat(1, stat:spd, current stat) == 30)
  assert(get hero stat(1, stat:spd, maximum stat) == 30)
  # but not current values for hp, mp
  assert(get hero stat(1, stat:hp, current stat) == 5)
  assert(get hero stat(1, stat:mp, current stat) == 12)
  # ...fix that up
  restore hp and mp
end

script, equipment tests, begin
  $0="equipment tests"
  # This is a continuation of 'hero stat tests', see that for preconditions
  # additional precondition: empty inventory, as well as:
  assert(find hero(hero:Freki) == 0)
  assert(find hero(hero:Helga) == 1)

  # test equipment commands
  get item(item:Boots)
  assert(inventory(item:Boots) == 1)
  assert(equip where(1, item:Boots) == slot:legs)  # equippable by all heroes
  assert(check equipment(1, slot:legs) == -1)
  assert(check equipment(1, slot:weapon) == item:DefltWep)  # default weapon  (not properly tested)
  assert(get default weapon(1) == item:DefltWep)

  force equip(1, slot:legs, item:Boots)
  # stat bonuses: spd+2 hp+3
  assert(check equipment(1, slot:legs) == item:Boots)
  assert(inventory(item:Boots) == 0)
  # test stat bonuses
  assert(get hero stat(1, stat:hp, current stat) == 10)
  assert(get hero stat(1, stat:hp, maximum stat) == 13)  # only affects max values of hp, mp
  assert(get hero stat(1, stat:spd, current stat) == 32)
  assert(get hero stat(1, stat:spd, maximum stat) == 32) # resets current value to max for other stats

  assert(inventory(item:SteelSho) == 0)
  assert(equip where(0, item:SteelSho) == slot:legs)  #equippable only by Freki
  assert(equip where(1, item:SteelSho) == false)

  # Note that force equip can be used to equip an item not in the inventory,
  # in that case you get a free copy.
  # Force equip also allows equipping in wrong slot
  force equip(1, slot:weapon, item:SteelSho)
  # stat bonuses: atk+3
  assert(check equipment(1, slot:weapon) == item:SteelSho)
  assert(check equipment(1, slot:legs) == item:Boots)
  assert(inventory(item:DefltWep) == 0)  # shouldn't gain a default weapon
  assert(get hero stat(1, stat:atk, current stat) == 13)
  assert(get hero stat(1, stat:atk, maximum stat) == 13)

  # test unequipping
  unequip(1, slot:legs)
  assert(inventory(item:Boots) == 1)
  assert(check equipment(1, slot:legs) == -1)

  set hero stat(1, stat:hp, 29, current stat)  # check effects of unequipping... even on stats
  set hero stat(1, stat:spd, 29, current stat) # which the equipment doesn't have bonuses on

  unequip(1, slot:weapon)
  assert(inventory(item:SteelSho) == 1)
  assert(check equipment(1, slot:weapon) == item:DefltWep)

  assert(get hero stat(1, stat:hp, current stat) == 10)  # current values of hp,mp should be capped to max
  assert(get hero stat(1, stat:hp, maximum stat) == 10)
  assert(get hero stat(1, stat:spd, current stat) == 30)
  assert(get hero stat(1, stat:spd, maximum stat) == 30) # resets current value to max for other stats

  # TODO: test equip elemental resists

  # test for Bug 743 - Unequipping items with stat bonuses that exceed stat limits is broken
  assert(get hero stat(1, stat:hp, current stat) == 10)  # preconditions (max same)
  assert(get hero stat(1, stat:spd, current stat) == 30)
  set hero stat cap(stat:hp, 5)
  set hero stat cap(stat:spd, 5)
  force equip(1, slot:legs, item:Boots)
  assert(get hero stat(1, stat:hp, current stat) == 5)  # cap hp, mp to the cap
  assert(get hero stat(1, stat:hp, maximum stat) == 5)
  assert(get hero stat(1, stat:spd, current stat) == 5) # resets current value to max for other stats
  assert(get hero stat(1, stat:spd, maximum stat) == 5)
  unequip(1, slot:legs)
  assert(get hero stat(1, stat:hp, current stat) == 5)
  assert(get hero stat(1, stat:hp, maximum stat) == 5)
  assert(get hero stat(1, stat:spd, current stat) == 5)
  assert(get hero stat(1, stat:spd, maximum stat) == 5)
  set hero stat cap(stat:hp, 0)
  set hero stat cap(stat:spd, 0)
  assert(get hero stat(1, stat:hp, current stat) == 5)  # only affects max values of hp, mp
  assert(get hero stat(1, stat:hp, maximum stat) == 10)
  assert(get hero stat(1, stat:spd, current stat) == 30)  # resets current value to max for other stats
  assert(get hero stat(1, stat:spd, maximum stat) == 30)
  # ...fix that up
  restore hp and mp
  assert(get hero stat(1, stat:hp, current stat) == 10)

  # cleanup
  delete item(item:SteelSho)
  delete item(item:Boots)
end

script, hero misc tests, begin
  $0="hero misc tests"
  show string(0), w
  variable(n)
  assert(hero by slot(0) == hero:Freki)
  assert(get hero hand x(0, hand:attack A) == 22)
  assert(get hero hand y(0, hand:attack A) == 11)
  assert(get hero hand x(0, hand:attack B) == 2)
  assert(get hero hand y(0, hand:attack B) == 17)
  set hero hand x(0, hand:attack A, 50)
  set hero hand y(0, hand:attack A, -25)
  set hero hand x(0, hand:attack B, -10)
  set hero hand y(0, hand:attack B, 1)
  assert(get hero hand x(0, hand:attack A) == 50)
  assert(get hero hand y(0, hand:attack A) == -25)
  assert(get hero hand x(0, hand:attack B) == -10)
  assert(get hero hand y(0, hand:attack B) == 1)
  set hero hand x(0, hand:attack A, get default hero hand x(0, hand:attack A))
  set hero hand y(0, hand:attack A, get default hero hand y(0, hand:attack A))
  set hero hand x(0, hand:attack B, get default hero hand x(0, hand:attack B))
  set hero hand y(0, hand:attack B, get default hero hand y(0, hand:attack B))
  assert(get hero hand x(0, hand:attack A) == 22)
  assert(get hero hand y(0, hand:attack A) == 11)
  assert(get hero hand x(0, hand:attack B) == 2)
  assert(get hero hand y(0, hand:attack B) == 17)
  
end

########################################################################

script, npc tests, begin
  npc movement tests(1)
  npc movement tests(NPC reference(1))
  npc id tests(NPC reference(1))
  npc tag and onetime tests
end

script, npc movement tests, n, begin
  $0="npc movement tests"
  $10="n=", append number(10, n)
  show string(0)
  
  # assert starting pos
  assert(npc X(n) == 3)
  assert(npc Y(n) == 5)
  # walk in a circle, testing speed
  set npc speed(n, 4)
  walk npc(n, south, 1), w
  wait for npc(n)
  assert(npc Y(n) == 6)
  set NPC speed(n, 5)
  walk npc(n, east, 1), w
  wait for npc(n)
  assert(npc X(n) == 4)
  set NPC speed(n, 10)
  walk npc(n, north, 1), w
  wait for npc(n)
  assert(npc Y(n) == 5)
  set NPC speed(n, 2)
  walk npc(n, west, 1), w
  wait for npc(n)
  assert(npc X(n) == 3)
  set npc speed(n, 4)
  
  set npc position(n, 3, 5)
  
  show no value
end

script, npc id tests, n, begin
  set npc direction(n, south), w
  assert(get npc id(n) == 1)
  change npc id(n, 2), w(4)
  assert(get npc id(n) == 2)
  change npc id(n, 1), w
end

script, npc tag and onetime tests, begin
  $0="npc onetime tests"
  variable(hx, hy, n)
  # Moving the hero in this script is a little silly,
  # but ensures that the onetime NPCs are on-screen
  # ...which they probably would have been anyway
  hx := hero x(me)
  hy := hero y(me)
  walk hero to y(me, 12)
  wait for hero(me), w
  walk hero to x(me, 4)
  wait for hero(me), w
  
  assert(check onetime(3) == false)
  assert(check onetime(4) == false)
  use npc(3), w
  assert(check onetime(3) == true)
  assert(check onetime(4) == false)
  use npc(4), w
  assert(check onetime(3) == true)
  assert(check onetime(4) == true)
  w
  n := npc reference(4)
  assert(n == false)
  set onetime(4, false), w
  n := npc reference(4)
  assert(n <> false)
  
  assert(check tag(10000) == false)
  w
  n := npc reference(5)
  assert(n <> false)
  set tag(10000, true)
  w
  n := npc reference(5)
  assert(n == false)
  assert(check tag(10000) == true)
  
  walk hero to x(me, hx)
  wait for hero(me), w
  walk hero to y(me, hy)
  wait for hero(me), w
end

########################################################################

script, trigger tests, begin
  harm tile tests
end

script, assert hurt pattern, test no, start hp, h0, h1, h2, h3, begin
  # h# is true if hero # should be hurt
  $0="assert hurt pattern, test no. "
  append number(0, test no)
  assert(get hero stat(0, stat:hp) == start hp -- h0)
  assert(get hero stat(1, stat:hp) == start hp -- h1)
  assert(get hero stat(2, stat:hp) == start hp -- h2)
  assert(get hero stat(3, stat:hp) == start hp -- h3)
  set hero stat(0, stat:hp, start hp)
  set hero stat(1, stat:hp, start hp)
  set hero stat(2, stat:hp, start hp)
  set hero stat(3, stat:hp, start hp)
end

script, harm tile tests, begin
  $0="harm tile tests"

  # Test harmtile damage
  walk hero to x(me, 7)
  walk hero to y(me, 6)
  wait for hero(me)

  variable(start hp)
  start hp := get hero stat(0, stat:hp, current stat)
  # hero is now at tile 7,6, caterpillar is enabled and not suspended, and all heroes have 'start hp' hp

  write map block(6, 6, 140, 1)
  write pass block(6, 6, harmtile)

  # Test damage to individual heroes, caterpillar enabled
  # also testing crossing over harmtile without stopping
  walk hero(me, left, 1)
  wait for hero(me), _checkpoint   # check for flash
  assert hurt pattern(0, start hp, true, false, false, false)
  walk hero(me, left, 2)
  wait for hero(me), _checkpoint
  assert hurt pattern(1, start hp, false, true, true, false)

  # Test damage to individual heroes, caterpillar suspended
  suspend caterpillar
  walk hero(1, right, 1)
  walk hero(2, down, 1)
  walk hero(3, left, 1)
  wait for hero(3)
  assert hurt pattern(2, start hp, false, true, false, true)

  # Test damage to whole party, caterpillar disabled
  set caterpillar mode(off)
  walk hero(me, right, 3)
  wait for hero(me)
  # "Harm tiles harm non-caterpillar party" is off
  assert hurt pattern(3, start hp, true, false, false, false)
  # Turn on "Harm tiles harm non-caterpillar party"
  write general(177, read general(177), or, 2^12)
  walk hero(me, left, 2)
  wait for hero(me)
  assert hurt pattern(4, start hp, true, true, true, true)
  # Check this makes no difference
  resume caterpillar
  walk hero(me, right, 1)
  wait for hero(me)
  assert hurt pattern(5, start hp, true, true, true, true)
  
  write map block(6, 6, 0, 1)
  write pass block(6, 6, 0)

  set caterpillar mode(on)
  # Caterpiller on and resumed, all heroes have 'start hp' hp
end

########################################################################

script, menu tests, begin
  $0="menu tests"
  variable(i, m, mi, main, m1)
  m := create menu, w
  if(get menu id(m) <> -1) then($0="get menu id should have reported -1 for script-generated menu", crash)
  
  mi := add menu item(m), w
  $1="Puppies"
  set menu item caption(mi, 1), w
  mi := add menu item(m), w
  $1="Kittens"
  set menu item caption(mi, 1), w
  mi := add menu item(m), w
  $1="Walruses"
  set menu item caption(mi, 1), w
  mi := add menu item(m), w
  $1="Octopus"
  set menu item caption(mi, 1), w
  mi := add menu item(m), w
  $1="Plip"
  set menu item caption(mi, 1), w

  main := open menu, w
  bring menu forward(bottom menu), w

  for(i, align:left, align:right) do(
    set menu anchor x(m, i), w
    if(get menu anchor x(m) <> i) then($0="menu anchor x", crash)
    set menu anchor y(m, i), w
    if(get menu anchor y(m) <> i) then($0="menu anchor y", crash)
  )

  $1="Puppies"
  mi := find menu item caption(m, 1)
  if(mi == 0) then($0="failed to find first menu item by caption", crash)
  get menu item caption(mi, 2)
  if(not(string compare(1, 2))) then($0="found menu item that was not puppies", crash)

  $1="Walruses"
  mi := find menu item caption(m, 1)
  get menu item caption(mi, 2)
  if(not(string compare(1, 2))) then($0="found menu item that was not walruses", crash)
  
  mi := find menu item caption(m, 1, mi) #search for Walruses starting after Walruses
  if(mi <> 0) then($0="find menu item walrus should have failed", crash)

  mi := add menu item(m)
  $1="Kittens"
  set menu item caption(mi, 1), w

  variable(kitten1, kitten2, walruses)
  #search for Kitten from top
  $1="Kittens"
  kitten1 := find menu item caption(m, 1)
  #search for Kitten starting after Walruses
  $2="Walruses"
  walruses := find menu item caption(m, 2) 
  kitten2 := find menu item caption(m, 1, walruses) 
  if(kitten1 == 0) then($0="failed to find first kitten", crash)
  if(kitten2 == 0) then($0="failed to find second kitten", crash)
  get menu item caption(kitten1, 2)
  if(not(string compare(1, 2))) then($0="found menu item that was not kitten(1)", crash)
  get menu item caption(kitten2, 2)
  if(not(string compare(1, 2))) then($0="found menu item that was not kitten(2)", crash)
  if(kitten1 == kitten2) then($0="found the same kitten twice", crash)

  mi := add menu item(m), w
  delete menu item(mi), w
  $1="Kittens"
  mi := find menu item caption(m, 1)
  delete menu item(mi), w
  mi := first menu item(m)
  delete menu item(mi), w

  if(find menu ID(1) <> 0) then($0="found unopened menu", crash)
  open menu(1),w
  m1 := find menu ID(1)
  if(get menu ID(m1) <> 1) then($0="get menu ID mismatch vs find menu", crash)
  if(m1 == 0) then($0="failed to find opened menu", crash)  
  close menu(m1),w

  for(i, -3, 12) do(
    set menu border(main, i), w
  )
  if(get menu border(main) <> 12) then($0="readback of menu border thickness failed", crash)
  for(i, 0, 10) do(
    set menu boxstyle(main, i)
  )
  if(get menu boxstyle(main) <> 10) then($0="readback of menu boxstyle failed", crash)

  for(i, 0, 15) do(
    set menu max chars(main, i), w
    if(get menu max chars(main) <> i) then($0="readback of menu max chars failed", crash)
  )
  set menu max chars(main, 0), w
  for(i, 10, 30) do(
    set menu min chars(main, i), w
    if(get menu min chars(main) <> i) then($0="readback of menu min chars failed", crash)
  )
  set menu min chars(main, 0), w

  for(i, -50, 50, 10) do(
    set menu offset x(main, i), w
    if(get menu offset x(main) <> i) then($0="readback of menu offset x failed", crash)
    set menu offset y(main, i), w
    if(get menu offset y(main) <> i) then($0="readback of menu offset y failed", crash)
  )
  set menu offset x(main, 0)
  set menu offset y(main, 0)
  for(i, align:left, align:right) do(
    set menu anchor x(main, i), w
    if(get menu anchor x(main) <> i) then($0="readback of menu anchor x failed", crash)
    set menu anchor y(main, i), w
    if(get menu anchor y(main) <> i) then($0="readback of menu anchor y failed", crash)
  )
  set menu anchor x(main, 0), w
  set menu anchor y(main, 0), w

  for(i, align:left, align:right) do(
    set menu text align(main, i), w
    if(get menu text align(main) <> i) then($0="readback of menu text align failed", crash)
  )
  set menu text align(main, 0), w

  set menu bit(main, 0, true), w  #Transparent box
  if(get menu bit(main, 0) <> true) then($0="failed to set menu bit", crash)
  set menu bit(main, 0, false), w #Opaque box
  if(get menu bit(main, 0) <> false) then($0="failed to unset menu bit", crash)
  variable(save rows)
  save rows := get menu max rows(main)
  set menu max rows(main, 3), w
  set menu bit(main, 1, true), w  #never show scrollbar
  set menu bit(main, 1, false), w #show scrollbar
  set menu max rows(main, save rows)
  set menu bit(main, 4, true), w  #no box
  set menu bit(main, 4, false), w #show box
  set menu bit(main, 8, true), w  #Advance text box when menu closes
  show text box(6), w
  if(not(menu is open(main))) then($0="why isn't the main menu open?", crash)
  close menu(top menu), w
  close menu(main), w
  if(current text box <> -1) then($0="menu bit failed to close textbox", crash)

  if(menu is open(main)) then($0="why is the main menu still open?", crash)

  variable(antelope, buffalo, catbus, duiker)
  m := create menu, w
  antelope := add menu item(m), $0="Antelope", set menu item caption(antelope, 0), w
  buffalo  := add menu item(m), $0="Buffalo",  set menu item caption(buffalo, 0), w
  catbus   := add menu item(m), $0="Catbus",   set menu item caption(catbus, 0), w
  duiker   := add menu item(m), $0="Duiker",   set menu item caption(duiker, 0), w

  # Hide when disabled 
  set menu item bit(catbus, 0, true), w
  if(get menu item bit(catbus, 0) <> true) then($0="menu item bit readback failed", crash)
  # Disable now
  set menu item type(catbus, menutype:label)
  set menu item subtype(catbus, 1), w
  # Don't hide
  set menu item bit(catbus, 0, false), w
  # Re-enable
  set menu item subtype(catbus, 0), w

  set menu item settag(catbus, 3)
  if(get menu item settag(catbus) <> 3) then($0="menu item settag readback failed", crash)
  if(check tag(3)) then($0="tag 3 shouldn't be on yet (menu)", crash)
  use menu item(catbus), w
  if(not(check tag(3))) then($0="tag 3 shouldn't be on now (menu)", crash)
  set menu item settag(catbus, 0)
  set menu item togtag(catbus, 3)
  use menu item(catbus), w
  if(check tag(3)) then($0="tag 3 should be toggled off (menu)", crash)
  use menu item(catbus), w
  if(check tag(3)==OFF) then($0="tag 3 should be toggled on (menu)", crash)
  use menu item(catbus), w
  if(check tag(3)) then($0="tag 3 should be toggled off again (menu)", crash)
  set menu item togtag(catbus, 0)

  for(i, 1, 2) do(
    set menu item tag(catbus, -3, i), w
    if(get menu item tag(catbus, i) <> -3) then($0="menu item tag readback failed", crash)
    set tag(3, ON), w
    set menu item tag(catbus, 3, i), w
    set tag(3, OFF), w
    set menu item tag(catbus, 0, i), w
  )

  $0="menu item tag req", show string(0)
  for(i, 1, 2) do(
    set tag(3, OFF)
    if(get menu item tag(catbus, i) <> 0) then($0="menu item tag req should be zero:", append number(0, i), crash)
    set menu item tag(catbus, 3, i), w
    if(get menu item tag(catbus, i) <> 3) then($0="menu item tag req readback fail:", append number(0, i), crash)
    set tag(3, ON), w
    set menu item tag(catbus, -3, i), w
    set tag(3, OFF), w
    set menu item tag(catbus, 0, i), w
  )
  show no value
  
  for(i, 0, 2) do(
    set menu item extra(buffalo, i, (i + 1) * 10)
    if(get menu item extra(buffalo, i) <> (i + 1) * 10) then($0="menu item extra readback failed", crash)
  )
  
  set menu item type(catbus, menutype: special)
  $0="" # use default caption
  set menu item caption(catbus, 0), w
  for (i, 0, 13) do(
    set menu item subtype(catbus, i), w
  )
  $0="Catbus, not Save"
  set menu item caption(catbus, 0), w
  $0=""
  set menu item caption(catbus, 0), w
  set menu item type(catbus, menutype:menu), w
  for(i, 0, 2) do(
    set menu item subtype(catbus, i), w
    if(get menu item subtype(catbus) <> i) then($0="menu item subtype readback failed", crash)
  )
  $0="Catbus"
  set menu item caption(catbus, 0), w
  
  # open another menu
  set menu item type(catbus, menutype:menu)
  set menu item subtype(catbus, 2)
  use menu item(catbus), w
  if(get menu id(top menu) <> 2) then($0="Failed to open a menu from a menu", crash)
  close menu(top menu), w

  # open a text box
  set menu item type(catbus, menutype:textbox)
  set menu item subtype(catbus, 7)
  use menu item(catbus), w
  if(current textbox <> 7) then($0="Failed to open a text box from a menu", crash)
  advance text box, w

  if(get menu item type(catbus) <> menutype:textbox) then($0="menu item type readback failed", crash)
  set menu item type(catbus, menutype:label)

  # run a script from a menu
  set menu item type(catbus, menutype:script)
  set menu item subtype(catbus, @on menu item use)
  use menu item(catbus), w
  if(menu item script global <> 99) then($0="Failed to run a script from a menu", crash)

  variable(oldcol)
  oldcol := get menu textcolor(m)
  for(i, 0, 10) do(
    set menu textcolor(m, i * 13), w
    if(get menu textcolor(m) <> i * 13) then($0="menu textcolor readback failed", crash)
  )
  set menu textcolor(m, oldcol)

  # iterate all menu items
  variable(count)
  count := 0
  mi := first menu item(m)
  while(mi) do(
    count += 1
    mi := next menu item(mi)
  )
  if(count <> 4) then($0="iterated wrong number of menu items (all)")
  # now hide catbus
  set menu item bit(catbus, menu item bit:hide when disabled, true)
  set menu item tag(catbus, 3)
  set tag(3, OFF)
  # iterate all except hidden
  count := 0
  mi := first menu item(m)
  while(mi) do(
    count += 1
    mi := next menu item(mi, true)
  )
  if(count <> 3) then($0="iterated wrong number of menu items (vis only)")
  # iterate all including hidden
  count := 0
  mi := first menu item(m)
  while(mi) do(
    count += 1
    mi := next menu item(mi, false)
  )
  if(count <> 4) then($0="iterated wrong number of menu items (vis only)")


  # close when selected
  set menu item bit(antelope, 1, true)
  use menu item(antelope), w
  if(top menu == m) then($0="Even Toed Ungulate menu failed to close", crash)

  menu close global := 0
  m := create menu, w
  mi := add menu item(m)
  $1="close me"
  set menu item caption(mi, 1), w
  set menu item bit(mi, menu item bit:close menu when selected, true)
  set menu on close script(m, @on close menu test)
  if(get menu on close script(m) <> @on close menu test) then($0="menu close script readback failed", crash)
  use menu item(mi), w
  if(menu close global <> 99) then($0="menu close script didn't run", crash)

  menu scroll tests
end

script, on menu item use, begin
  menu item script global := 99
end

script, on close menu test, begin
  menu close global := 99
end


script, scroll through menu, menu, numitems, begin
  variable (i, j, mi)

  # test scrolling
  for (i, 1, 3, 2) do (
    set menu max rows(menu, i)
    # forwards
    mi := first menu item(menu)
    while (mi) do (
      select menu item(mi), w
      mi := next menu item(mi)
    )
    # backwards
    mi := menu item by slot(menu, numitems -- 1)
    while (mi) do (
      select menu item(mi), w
      mi := previous menu item(mi)
    )
    # randomly
    for (j, 0, 4) do (
      select menu item(menu item by slot(menu, random(0, numitems -- 1))), w
    )
  )
  set menu max rows(menu, 0)
end

script, menu scroll tests, begin
  $0="menu scroll tests"

  variable (main, mi, next, i, numitems)
  main := open menu, w
  set menu bit(main, 1, false), w #show scrollbar
  allow minimap(true), w #make sure there are no hidden items
  allow save anywhere(true), w

  # test menu item iteration
  mi := first menu item(main)
  while (mi) do (
    get menuitemcaption(mi,10)
    #trace(10)
    appendnumber(10, numitems)
    assert (menu item slot(mi) == numitems)
    assert (menu item by slot(main, numitems, true) == mi)
    assert (menu item by slot(main, numitems, false) == mi)
    assert (menu item true slot(mi) == numitems)
    assert (menu item by true slot(main, numitems) == mi)
    next := next menu item(mi, false)
    if (next) then (
      assert (mi == previous menu item(next))
    )
    set menu item extra(mi, 0, numitems)
    mi := next
    numitems += 1
  )
  $10=""

  # menu item iteration edge cases
  assert (previous menu item(first menu item(main)) == 0)
  assert (next menu item(menu item by slot(main, numitems -- 1)) == 0)
  assert (menu item by slot(main, numitems, true) == 0)
  assert (menu item by slot(main, numitems, false) == 0)
  assert (menu item by slot(main, -1) == 0)
  assert (menu item by true slot(main, -1) == 0)
  assert (menu item by true slot(main, numitems) == 0)

  # test "select menu item"
  mi := first menu item(main)
  while (mi) do (
    select menu item(mi), w
    assert (selected menu item(main) == mi)
    mi := next menu item(mi)
  )

  # test scrolling
  scroll through menu(main, numitems)

  # check hidden items sorted to end:
  # 1. hide three items
  set tag(3, OFF)
  variable(hidden1, hidden2, hidden3)
  hidden3 := menu item by slot(main, 4)
  set menu item bit(hidden3, menu item bit: hide when disabled, true)
  set menu item tag(hidden3, 3, 1)
  hidden1 := menu item by slot(main, 0)
  set menu item bit(hidden1, menu item bit: hide when disabled, true)
  set menu item tag(hidden1, 3, 1)
  hidden2 := menu item by slot(main, 3)
  set menu item bit(hidden2, menu item bit: hide when disabled, true)
  set menu item tag(hidden2, 3, 1)
  w

  # 2. add new item
  mi := add menu item(main)
  set menu item extra(mi, 0, numitems)
  numitems += 1
  $1="a new item!"
  set menu item caption(mi, 1), w

  # 3. check visible items in correct order
  variable (temp, extra, mi2)
  temp := -1
  for (i, 0, num items -- 3 -- 1) do (
    mi := menu item by slot(main, i, true)
    mi2 := menu item by slot(main, i, false)
    assert (mi == mi2)
    extra := get menu item extra(mi2, 0)
    if (extra <= temp) then ($0="menu items not in increasing order", crash)
    temp := extra
  )

  # 4. check hidden items at end in correct order
  if (menu item by slot(main, numitems -- 3, true) <> 0) then ($0="menuitembyslot returned hidden item", crash)
  if (menu item by slot(main, numitems -- 3, false) <> hidden1) then ($0="hidden items out of order", crash)
  if (menu item by slot(main, numitems -- 2, false) <> hidden2) then ($0="hidden items out of order", crash)
  if (menu item by slot(main, numitems -- 1, false) <> hidden3) then ($0="hidden items out of order", crash)
  assert (menu item by slot(main, numitems, false) == 0)

  # 5. check "true order" hasn't changed
  for (i, 0, num items -- 1) do (
    mi := menu item by true slot(main, i)
    assert (menu item true slot(mi) == i)
    assert (get menu item extra(mi, 0) == i)
  )

  # test scrolling again
  scroll through menu(main, numitems -- 3)

  # check unhidden menu items sorted back correctly
  set tag(3, ON), w
  for (i, 0, numitems -- 1) do (
    mi := menu item by slot(main, i, false)
    assert (mi == menu item by slot(main, i, true))
    assert (get menu item extra(mi, 0) == i)
  )

  close menu(main)
end

#next menu(menu handle)
#open menu (ID, allow duplicate)
#parent menu(menu item handle)
#previous menu(menu handle)
#swap menu items(handle1, handle2)
#wait for menu (menu handle)

########################################################################

script, textbox tests, begin
  $0="textbox tests"
  show text box(2), w
  advance text box, w
  show text box(3), w
  advance text box, w
  if(current textbox <> 4) then(crash)
  advance text box, w
  show text box(3), w
  advance text box, w
  if(current textbox <> 5) then(crash)
  advance text box, w
  if(current textbox <> -1) then(crash)
  w
  show text box(12), w, advance text box, w
  show text box(13), w, advance text box, w
end

########################################################################

script, battle tests, begin
  # there are some other battle tests in with the timer tests
  $0="battle tests"
  show value(random(1, 999999999)), w
  force random battle(1)
  show value(random(1, 999999999)), w # this should remain deterministic after battle
  show no value, w
  # attack forces run
  assert(fight formation(1) == false), w
  # attack forces victory
  assert(fight formation(2) == true), w
  # attack forces exit
  assert(fight formation(3) == false), w
  # test tag check: battle should not trigger
  force random battle(2)
  assert(last formation <> 4)
  w(5)
  fight formation(5)
  w(5)
  # Test attacks setting tags.
  set tag(4, false)
  set tag(5, false)
  fight formation(6)
  w(5)
  # The first time should NOT set tag 5 because tag 4 was not set
  assert(not(check tag(5))), w
  set tag(4, true)
  fight formation(6)
  w(5)
  # The second time SHOULD set tag 5 because tag 4 WAS set
  assert(check tag(5)), w
  set tag(6, false)
  fight formation(7)
  w(5)
  # The third one should always turn the tag on because the tag check is 0.
  assert(check tag(6)), w
end

# Formation set should be 1-3
script, force random battle, formation set = 1, begin
  variable(s, x, y, d)
  if (formation set == 0) then (formation set := 1)  # If run with runscriptbyid
  # save hero state
  s := get hero speed(me)
  x := hero x(me)
  y := hero y(me)
  d := hero direction(me)
  # get the hero ready for forcing the battle
  set hero speed(0, 20)
  # Formations 1-3 are at x = 14-16
  set hero position(0, 13 + formation set, 9), w
  # force the battle
  walk hero(0, north, 1), w
  # restore hero state
  set hero speed(me, s)
  set hero position(me, x, y)
  set hero direction(me, d)
  w
end

script, force non random battle, begin
  w
  fight formation(0)
  w(2)
end

plotscript, after battle, begin
  $0="After battle script:"
  battle script sequence += 1
  append number(0, battle script sequence)
  trace(0)
  show string at(0, 0, 0)
  w
  hide string(0)
end

plotscript, instead of battle, form, begin
  $0="Instead of battle script("
  append number(0, form)
  $0+")"
  trace(0)
  w
  fight formation(form)
  $0="  finish instead of battle"
  trace(0)
end

########################################################################

script, enemy tests, begin
  $0="enemy tests"

  assert(enemy elemental resist as int(enemy:Data Read Test, 2) == 0)
  assert(enemy elemental resist as int(enemy:Data Read Test, 15) == -5)

  # Name
  get enemy name(enemy:Data Read Test, 1)
  $2 = "Data read test"
  assert(string compare(1, 2))
  $2 = "Data read test2"
  set enemy name(enemy:Data Read Test, 2)
  get enemy name(enemy:Data Read Test, 1)
  assert(string compare(1, 2))

  # Stats
  assert(get enemy stat(enemy:Data Read Test, stat:HP) == 13)
  set enemy stat(enemy:Data Read Test, stat:Hits, 6)
  assert(get enemy stat(enemy:Data Read Test, stat:Hits) == 6)

  # Other
  set enemy appearance(enemy:Data Read Test, Enemy:PictureSize, EnemySize:large)
  assert(get enemy appearance(enemy:Data Read Test, Enemy:PictureSize) == EnemySize:large)
  assert(get enemy appearance(enemy:Data Read Test, Enemy:Palette) == -1)
  assert(read enemy data(enemy:Data Read Test, Enemy:Item) == 1)
  assert(read enemy data(enemy:Data Read Test, Enemy:ItemPercent) == 50)
  write enemy data(enemy:Data Read Test, Enemy:RareItem, 2)
  assert(read enemy data(enemy:Data Read Test, Enemy:RareItem) == 2)
end

########################################################################

script, timer tests, begin
  variable(i)
  
  allocate timers(32)
  set timer(31, 10, 1, @timer test 1, 1)
  show string at(1, 10, 10)
  w, w, w, w
  if(read timer(31) <> 6) then($0="read timer failed", crash)
  w(6), w

  timer global := 100
  set timer(31, 0, 1, @looping timer test, 1)
  w(11)
  
  $10="random"
  test timer and battle interactions(@force random battle)
  $10="fight formation"
  test timer and battle interactions(@force non random battle)
  $10=""

  
  $0="timer interactions with after battle", trace(0)
  teleport to map(1, 10, 8), w # after battle
  battle script sequence := 0
  test timer and battle interactions(@force random battle)
  if(battle script sequence <> 3) then($0="(ab) afterbattle should have happened 3 times", crash)

  $0="timer interactions with instead of battle", trace(0)
  teleport to map(2, 10, 8), w # instead of battle
  battle script sequence := 0
  test timer and battle interactions(@force random battle)
  if(battle script sequence <> 0) then($0="(ib) afterbattle should have happened 0 times", crash)

  $0="timer interactions with after battle + instead of battle", trace(0)
  teleport to map(3, 10, 8), w # after battle + instead of battle
  battle script sequence := 0
  test timer and battle interactions(@force random battle)
  if(battle script sequence <> 3) then($0="(ab+ib) afterbattle should have happened 3 times", crash)

  teleport to map(0, 10, 8), w

  hide string(1)
end

script, test timer and battle interactions, trigger battle, begin
  #regular timer
  timer global := 0
  timer global will become := 1000
  set timer(31, 10, 1, @battle timer test, -1, 0)
  run script by id(trigger battle)
  if(read timer(31) <= 0) then($0="timer should still be running", crash)
  if(timer global <> 0) then($0="timer global should still be zero", crash)
  w(10)
  if(read timer(31) >> 0) then($0="timer should be done by now", crash)
  if(timer global <> timer global will become) then($0="timer global didn't change", crash)
  
  #timerflag:battle
  timer global := 0
  timer global will become := 2000
  set timer(31, 10, 1, @battle timer test, 1, timerflag:battle)
  run script by id(trigger battle)
  if(read timer(31) >> 0) then($0="(bat) timer should be done by now", crash)
  if(timer global <> timer global will become) then($0="(bat) timer global didn't change", crash)

  #timerflag:battle ,or, timerflag:critical
  timer global := 0
  timer global will become := 3000
  set timer(31, 10, 1, @battle timer test, 1, (timerflag:battle,or,timerflag:critical))
  set timer(30, 20, 1, @battle timer test, 0, (timerflag:battle))
  run script by id(trigger battle)
  if(read timer(31) >> 0) then($0="(bat+crit) timer should be done by now", crash)
  if(timer global <> timer global will become) then($0="(bat+crit) timer global didn't change", crash)
  timer global will become := 4000
  if(read timer(30) <= 0) then($0="(bat+crit) second timer should still be running", crash)
  w(12)
  if(read timer(30) >> 0) then($0="(bat+crit) second timer should be done by now", crash)
  if(timer global <> timer global will become) then($0="(bat+crit) timer global didn't change on second timer", crash)
  timer global := 0
  w
end

script, timer test 1, begin
  show value(12345)
  w
end

script, looping timer test, begin
  if(timer global <= 0) then(timer global := 0, exit script)
  set timer(31, 0, 1, @looping timer test, 1)
  timer global -= 10
  show value(timer global)
  _checkpoint
end

script, battle timer test, begin
  timer global := timer global will become
  $0="battle timer test:"
  append number(0, timer global)
  trace(0)
  show string(0), w
end

########################################################################

script, string tests, begin
  # There are tons more string commands we could test here!
  $0="String tests", trace(0)

  $1=""
  $2=""
  assert(string compare(1,2))
  $1="a"
  $2="A"
  assert(string compare(1,2) == false)
  $1=" .~fooy"
  $2=" .~fooY"
  assert(string compare(1,2) == false)

  # Check HSpeak encodes Unicode correctly
  $1="	 ¡éÖœ£"  # tab, space, exclamation
  $2="‰Œẽñ"  # characters above U+00FF
  $3="???ñ"
  trace(3)
  assert(string compare(2, 3))
  3 $= 1
  3 $+ 2
  trace(3)
  trace value(string length(3))
  assert(string length(3) == 11)
  assert(ascii from string(3, 1) == 9)
  assert(ascii from string(3, 2) == 32)
  assert(ascii from string(3, 3) == 161)
  assert(ascii from string(3, 4) == 233)
  assert(ascii from string(3, 10) == 63)
  assert(ascii from string(3, 11) == 241)
  show string at(3, 0, 0)
  w
  hide string(3)

  $1="SelfStab"
  read attack name(2, 0 + 1)
  assert(string compare(1,2))
  
  $1="Attack self"
  get attack caption(2, 0 + 1)
  assert(string compare(1,2))

  embedding global := -1234
  $3="<embedded> "

  # Test the obsolete stringfromtextbox: 4th arg ignored
  stringfromtextbox(1, 8, 2)
  $2="."
  assert(string compare(1, 2))
  stringfromtextbox(1, 8, 3)
  $2=""
  assert(string compare(1, 2))
  stringfromtextbox(1, 8, 4)
  $2="##"
  assert(string compare(1, 2))
  stringfromtextbox(1, 8, 5, false)
  $2=",-1234. ,<embedded> "
  assert(string compare(1, 2))
  stringfromtextbox(1, 8, 5, true)
  assert(string compare(1, 2))

  # textbox line
  textboxline(1, 8, 2)
  $2="."
  assert(string compare(1, 2))
  textboxline(1, 8, 3)
  $2=""
  assert(string compare(1, 2))
  textboxline(1, 8, 4)
  $2=" ## "
  assert(string compare(1, 2))
  textboxline(1, 8, 4, true, false)
  assert(string compare(1, 2))
  textboxline(1, 8, 4, true, true)
  $2="##"
  assert(string compare(1, 2))
  textboxline(1, 8, 5, false)
  $2=" ,${V105}. ,${S3} "
  assert(string compare(1, 2))
  textboxline(1, 8, 5, true)
  $2=" ,-1234. ,<embedded>  "
  assert(string compare(1, 2))
  textboxline(1, 8, 5, true, true)
  $2=",-1234. ,<embedded> "
  assert(string compare(1, 2))

  # higher IDs
  $95="a "
  $96=""
  appendascii(96, 97)
  $96+" "
  assert(string compare(95, 96))
end

########################################################################

script, door tests, begin
  $0="Door tests"
  assert(get door x(0) == 8)
  assert(get door y(0) == 5)
  assert(get door destination id(0) == 1)
  assert(get door destination map(0) == 4)
  assert(door exists(0))
  assert(get door destination id(1) == -1)
  assert(get door destination map(1) == -1)
  assert(door exists(1))
  assert(door exists(2) == false)
end

########################################################################

script, slice tests, begin
  $0="Slice tests"

  # Extremely unfinished!

  # Test rect transparency
  variable (sl)
  sl := create rect(100, 100), w
  assert(get rect trans(sl) == trans:solid)
  assert(get rect fuzziness(sl) == 100)
  set rect trans(sl, trans:hollow), w
  assert(get rect trans(sl) == trans:hollow)
  assert(get rect fuzziness(sl) == 0)
  set rect fuzziness(sl, 25), w
  assert(get rect trans(sl) == trans:fuzzy)
  assert(get rect fuzziness(sl) == 25)
  set rect fuzziness(sl, 0), w
  assert(get rect trans(sl) == trans:hollow)
  assert(get rect fuzziness(sl) == 0)
  set rect fuzziness(sl, 100), w
  assert(get rect trans(sl) == trans:solid)
  assert(get rect fuzziness(sl) == 100)
  set rect trans(sl, trans:fuzzy), w
  assert(get rect trans(sl) == trans:fuzzy)
  assert(get rect fuzziness(sl) == 50)
  free slice(sl)

  # Text slices
  $2="fee Fi\n \n foe"
  sl := create text
  set slice text(sl, 3)
  get slice text(2, sl)
  assert(string compare(2, 3))
  $2=""
  $3=""
  free slice(sl)
end

########################################################################

script, save load tests, begin
  $0="Saving/loading tests"

  assert(save slot used(1) == false)
  delete save(1)
  assert(save slot used(1) == false)

  # import/export globals

  export global 1 := -123456789
  export globals(1, @export global 1, @export global 1)
  export global 1 := -2
  assert(import globals(1, @export global 1) == -123456789)
  assert(export global 1 == -2)
  import globals(1, @export global 1, @export global 2)
  assert(export global 1 == -123456789)
  assert(export global 2 == 0)
  export global 2 := -100
  export globals(1, @export global 2, @export global 2)
  save in slot(2)
  export global 1 := 0
  export global 2 := 0
  export globals(1, @export global 1, @export global 2)
  export global 1 := 100
  export global 2 := 100
  import globals(1, @export global 1, @export global 2)
  assert(export global 1 == 0)
  assert(export global 2 == 0)

  # exporting globals should not cause a slot to appear as used
  assert(save slot used(1) == false)
  assert(save slot used(2) == true)

  # testing saveinslot earlier
  import globals(2, @export global 1, @export global 2)
  assert(export global 1 == -123456789)
  assert(export global 2 == -100)

  # different form
  export global 1 := -3
  assert(import globals(2, @export global 1, @export global 1) == 0)
  assert(export global 1 == -123456789)

  # loading from nonexistent save... it's not actually specified
  # what's meant to happen, but this is reasonable
  import globals(3, @export global 1, @export global 2)
  assert(export global 1 == 0)
  assert(export global 2 == 0)

  # delete save is meant to preserve stored global variables  (FAILS!!)
  delete save(1)
  delete save(2)
  assert(save slot used(1) == false)
  assert(save slot used(2) == false)
  export global 1 := -1
  export global 2 := -2
  #import globals(1, @export global 1, @export global 2)
  #assert(export global 1 == 0)
  #assert(export global 2 == 0)
  #import globals(2, @export global 1, @export global 2)
  #assert(export global 1 == -123456789)
  #assert(export global 2 == -100)

end

########################################################################

########################################################################
#### COMMANDS THAT STILL NEED TESTS
#### (Note: interactive commands should be in interactivetest.hss)
#add enemy to formation (formation, enemy id, x, y, slot)
#allow minimap (setting)
#allow save anywhere (setting)
#alter NPC (who,NPCstat,value)
#value,and,value
#animation start tile (tile number, layer)
#append ascii (ID, char)
#append number (ID, number)
#ascii from string (ID, position)
#autosave
#break
#camera follows hero (who)
#camera follows NPC (who)
#camera pixel X
#camera pixel Y
#cancel map name display
#center slice (handle)
#center string at (ID, x, y)
#change tileset (tileset, layer)
#check NPC wall (who, direction)
#check parentage (handle, parent handle)
#check tag (tag)
#child count (handle)
#clamp slice (handle1, handle2)
#clear string(ID)
#clone sprite (handle)
#concatenate strings (dest, source)
#continue
#copy string (dest, source)
#create container (width, height)
#create ellipse (width, height, border color, fill color)
#create grid (width, height, rows, columns)
#create NPC (ID,X,Y,direction)
#create rect (width, height, style)
#create text
#current display tile (tile number, layer)
#current map
#current stat
#days of play
#decrement (variable,amount)
#delete char (ID, position)
#delete enemy from formation (formation, slot)
#delete map state (whichdata)
#delete save (slot)
#destroy NPC (reference)
#dismount vehicle
#number / number
#draw NPCs above heroes (setting)
#number == number
#exit returning(value)
#exit script
#expand string(ID)
#number ^ power
#extended scancodes enabled
#extract color(color, component)
#fade screen in
#fade screen out (red,green,blue)
#fight formation (number)
#fill parent (handle, true_or_false)
#find colliding slice (parent, slice, number, check descendants)
#find enemy in formation (formation, enemy id, copy number)
#first child(handle)
#first container child(handle)
#first rect child(handle)
#first sprite child(handle)
#focus camera (x,y,speed)
#for(counter,start,finish,step) do(commands)
#formation probability (formation set, formation)
#formation set frequency (formation set)
#formation slot enemy (formation, slot)
#formation slot x (formation, slot)
#formation slot y (formation, slot)
#free slice (handle)
#free slice children (handle)
#free sprite (handle)
#game over
#get ambient music
#get attack name
#get bottom padding (handle)
#get color(index)
#get damage cap
#get death script
#get each step script
#get ellipse border col (handle)
#get ellipse fill col (handle)
#get foot offset
#get formation background (formation, background)
#get formation song (formation)
#get global string (ID, global)
#get grid columns (handle)
#get grid rows (handle)
#get hero slice (who)
#get instead of battle script
#get item name (ID, item)
#get left padding (handle)
#get load script
#get map edge mode
#get map name (ID, map)
#get map tileset
#get money (amount)
#get NPC ignores walls (who)
#get NPC moves (who)
#get NPC obstructs (who)
#get NPC slice (who)
#get NPC usable (who)
#get on keypress script
#get outline(handle)
#get rect bgcol (handle)
#get rect border (handle)
#get rect fgcol (handle)
#get rect style (handle)
#get right padding (handle)
#get slice clipping (handle)
#get slice extra (handle, extra)
#get slice lookup (handle)
#get slice velocity x (handle)
#get slice velocity y (handle)
#get slice visible (handle)
#get song name (ID, song)
#get sort order (handle)
#get sprite frame (handle)
#get sprite palette (handle)
#get sprite set number (handle)
#get sprite trans (handle)
#get sprite type (handle)
#get text bg(handle)
#get text color(handle)
#get tile animation offset (animation pattern, layer)
#get top padding (handle)
#get victory music
#get wrap(handle)
#get zone extra (zone id, extra num)
#get zone name (string id, zone id)
#globals to string(ID, starting global, length)
#number >> number
#number >= number
#greyscale palette (first, last)
#grid is shown (handle)
#hide battle health meter (state)
#hide battle ready meter (state)
#hide string (ID)
#horiz flip sprite (handle, flip)
#hours of play
#increment (variable,amount)
#inside battle
#is filling parent (handle)
#last child(handle)
#last formation
#last save slot
#layer tileset (layer)
#leader
#number << number
#number <= number
#load attack sprite (num, palette)
#load backdrop sprite (num)
#load border sprite (num, palette)
#load from slot (slot)
#load hero sprite (num, palette)
#load large enemy sprite (num, palette)
#load map state (whichdata, customid)
#load medium enemy sprite (num, palette)
#load palette (palette number)
#load portrait sprite (num, palette)
#load slice collection (id)
#load small enemy sprite (num, palette)
#load tileset (tileset, layer)
#load walkabout sprite (num, palette)
#load weapon sprite (num, palette)
#value && value
#value || value
#value ^^ value
#lookup slice (lookup code, start slice)
#lose money (amount)
#map cure (attack, target, attacker)
#map height (map)
#map width (map)
#milliseconds
#minutes of play
#number,mod,number
#move slice above (handle, above what handle)
#move slice below (handle, below what handle)
#move slice by (handle, relative x, relative y, ticks)
#move slice to (handle, x, y, ticks)
#number * number
#next container sibling(handle)
#next rect sibling(handle)
#next sibling(handle)
#next sprite sibling(handle)
#not (value)
#number <> number
#NPC at pixel (x, y, number)
#NPC at spot (x, y, number)
#NPC copy count (ID)
#NPC direction (who)
#NPC extra (who, which)
#NPC frame (who)
#NPC is walking (who)
#NPC pixel X (who)
#NPC pixel Y (who)
#NPC reference (ID, copy)
#NPC X (who)
#NPC Y (who)
#number from string (ID, default)
#value,or,value
#order menu
#outside battle
#outside battle cure
#overhead tile
#pan camera (direction,distance,pixelstep)
#parent slice (handle)
#party money
#pay money (amount)
#place sprite
#positionstring (ID, x, y)
#previous sibling(handle)
#put camera (x,y)
#put npc (who,x,y)
#put slice (handle, X, Y)
#put slice screen (handle, x, y)
#put sprite (handle, x, y)
#random (lownumber, highnumber)
#random formation (formation set)
#read attack name (ID, attack)
#read color (index, element)
#read global (id)
#read map block (x,y,layer)
#read NPC (who,NPCstat)
#read pass block (x,y)
#read timer (id)
#read zone (zone id, x, y)
#realign slice (handle, horiz align, vert align, horiz anchor, vert anchor)
#replace attack sprite (handle, num, palette)
#replace backdrop sprite (handle, num)
#replace border sprite (handle, num, palette)
#replace char (ID, position, char)
#replace hero sprite (handle, num, palette)
#replace large enemy sprite (handle, num, palette)
#replace medium enemy sprite (handle, num, palette)
#replace portrait sprite (handle, num, palette)
#replace small enemy sprite (handle, num, palette)
#replace walkabout sprite (handle, num, palette)
#replace weapon sprite (handle, num, palette)
#reset game
#reset map state (whichdata)
#reset palette
#resume map music
#resume NPCs
#resume NPC walls
#resume obstruction
#resume overlay
#resume random enemies
#resume random enemys
#resume timers
#RGB(red, green, blue)
#run script by ID (id, argument1, argument2, argument3...)
#save in slot (slot)
#save map state (whichdata, customid)
#save menu (reallysave)
#search string (ID1, ID2, start)
#seconds of play
#seed random (new seed)
#set battle wait mode (state)
#set bottom padding (handle, pixels)
#set color(index, value)
#set damage cap (cap)
#set days of play (days)
#set death script (id)
#set debug keys disable (state)
#set each step script (id)
#set ellipse border col (handle, color)
#set ellipse fill col (handle, color)
#set foot offset (offset)
#set formation background (formation, background, animation frames, animation ticks)
#set formation song (formation, song)
#set grid columns (handle, columns)
#set grid rows (handle, rows)
#set harm tile damage (amount)
#set harm tile flash (color)
#set horiz align (handle, edge)
#set horiz anchor (handle, edge)
#set hours of play (hours)
#set inn no revive mode (state)
#set instead of battle script (id)
#set inventory size (new size)
#set left padding (handle, pixels)
#set load script (id)
#set map edge mode (mode, default tile)
#set minutes of play (min)
#set money (amount)
#set no HP level up restore (state)
#set no MP level up restore (state)
#set NPC direction (who, direction)
#set NPC extra (who, which, value)
#set NPC frame (who, frame)
#set NPC ignores walls (who, value)
#set NPC moves (who, value)
#set NPC obstructs (who, value)
#set NPC position (who, X, Y)
#set NPC speed (who, speed)
#set NPC usable (who, value)
#set on keypress script (id)
#set outline(handle, outline)
#set padding (handle, pixels)
#set parent (handle, parent handle)
#set rect bgcol (handle, color)
#set rect border (handle, border)
#set rect fgcol (handle, color)
#set rect style (handle, style)
#set right padding (handle, pixels)
#set seconds of play (sec)
#set slice clipping (handle, clip)
#set slice edge x (handle, edge, value)
#set slice edge y (handle, edge, value)
#set slice extra (handle, extra, value)
#set slice height (handle, height)
#set slice lookup (handle, code)
#set slice screen x (handle, x)
#set slice screen y (handle, y)
#set slice velocity (handle, horiz pixels per tick, vert pixels per tick, ticks)
#set slice velocity x (handle, pixels per tick, ticks)
#set slice velocity y (handle, pixels per tick, ticks)
#set slice visible (handle, vis)
#set slice width (handle, width)
#set slice x (handle, X)
#set slice y (handle, Y)
#set sort order (handle, order)
#set sprite frame (handle, num)
#set sprite palette (handle, num)
#set sprite trans (handle, drawtransparent)
#set sprite visible
#set tag (tag,value)
#set text bg(handle, color)
#set text color(handle, color)
#set tile animation offset (animation pattern, offset, layer)
#set timer (id, count, speed, trigger, string, flags)
#set top padding (handle, pixels)
#variable := value
#set vert align (handle, edge)
#set vert anchor (handle, edge)
#set wrap(handle, wrap)
#set zone extra (zone id, extra num, value)
#show backdrop (number)
#show grid (handle, shown)
#show map
#show no value
#show string (ID)
#show string at (ID, x, y)
#show value (number)
#sign (number)
#slice at pixel (parent, x, y, number, check descendants)
#slice child (handle, number)
#slice collide (handle1, handle2)
#slice collide point (handle, x, y)
#slice contains (handle1, handle2)
#slice edge x (handle, edge)
#slice edge y (handle, edge)
#slice height (handle)
#slice is container (handle)
#slice is ellipse (handle)
#slice is grid (handle)
#slice is moving (handle)
#slice is rect (handle)
#slice is sprite (handle)
#slice is text (handle)
#slice is valid (id)
#slice screen x (handle)
#slice screen y (handle)
#slice to back (handle)
#slice to front (handle)
#slice width (handle)
#slice x (handle)
#slice y (handle)
#sort children (handle, wipe)
#sprite frame count (handle)
#sprite is horiz flipped (handle)
#sprite is vert flipped (handle)
#sprite layer
#sqrt (number)
#stop slice (handle)
#stop timer (id)
#string color (ID, foreground color, background color)
#string is visible (ID)
#string length (ID)
#string style (ID, style)
#string to globals (ID, starting global, length)
#string X (ID)
#string Y (ID)
#number -- number
#suspend catapillar
#suspend map music
#suspend NPCs
#suspend NPC walls
#suspend obstruction
#suspend overlay
#suspend random enemies
#suspend random enemys
#suspend timers
#system day
#system hour
#system minute
#system month
#system second
#system year
#teleport to map (map, x, y)
#trace (string)
#trace value (expression, ...)
#trim string (ID, start, length)
#tweak palette (red, green, blue, first, last)
#update palette
#use door (number)
#use item (item)
#use item in slot(slot)
#use NPC (who)
#vert flip sprite (handle, flip)
#wait for all
#wait for camera
#wait for NPC (who)
#wait for slice (handle)
#walk NPC (who, direction, distance)
#walk NPC to X (who, X)
#walk NPC to Y (who, Y)
#write color (index, element, value)
#write global (id,value)
#write map block (x,y,value,layer)
#write pass block (x,y,value)
#write zone (zone id, x, y, value)
#value,xor,value
#Y sort children (handle)
#zone at spot (x, y, count)
#zone number of tiles (zone id)
