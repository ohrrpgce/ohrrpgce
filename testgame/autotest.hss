########################################################################
# Many of the tests in this script might seem silly. That is okay.
#
# Any time you are preparing to fix an engine bug, consider adding a
# test that demonstrates the bug FIRST before you fix the bug.

include, plotscr.hsd

########################################################################

define constant(1, default wait)

global variable(100, menu item script global)
global variable(101, timer global)
global variable(102, timer global will become)
global variable(103, battle script sequence)
global variable(104, menu close global)

#string 0 = error messages
#string 1 = temporary misc
#string 10 = error message arg
#string 11 = asserts
define constant(11, assert expression string)

########################################################################

plotscript, run all tests, begin
  suspend player
  seed random(4444)
  math tests
  hero tests
  npc tests
  menu tests
  textbox tests
  battle tests
  timer tests
  game over
end

########################################################################

script, w, ticks=default wait, begin
  wait(ticks)
  _checkpoint
end

script, crash, begin
  if(string length(10) >> 0) then(
    $0+"("
    concatenate strings(0, 10)
    $0+")"
  )
  show text box(1)
  trace(0)
  w(25)
  game over
end

script, assert failure, begin
  trace(assert expression string)
  crash
end

########################################################################

script, math tests, begin
  variable(n)
  n := 10
  $0="math tests"
  if(abs(-10) <> n) then(crash)
  if(abs(15) <> n + 5) then(crash)
end

########################################################################

script, hero tests, begin
  hero party management tests
  hero caterpillar tests
  hero exp and levels tests
  hero stat growth test
end

## spell lists
#can learn spell (hero,attack)
#forget spell (hero,attack)
#knows spell (hero,attack)
#read spell (hero,list,slot)
#teach spell (hero,attack)
#write spell (hero,list,slot,attack)

## Equipment
#check equipment (hero,slot)
#equip where (hero,item)
#force equip (hero,slot,item)
#get default weapon (hero)
#set default weapon (hero,item)
#unequip (hero,slot)

## Stats
#get hero stat (who,stat,type)
#set hero stat (who,stat,value,type)
#get hero stat cap (stat)
#set capped hero stat (who,stat,value,type)
#get level MP (who, mp level slot)
#set level MP (who, mp level slot, new value)

## Appearance
#get hero palette (who,type)
#get hero picture (who,type)
#reset hero palette (who,type)
#reset hero picture (who,type)
#set hero palette (who,palette,type)
#set hero picture (who,picture,type)

## Misc
#hero base elemental resist as int (who, element)
#hero total elemental resist as int (who, element)
#set hero base elemental resist (who, element, percent)

# Because I don't want to bother with having an HSI file right now

define constant(
0,hero:Freki
1,hero:Helga
2,hero:Olaf
3,hero:Frumpy
4,hero:Styrge
5,hero:Kitt
)

script, hero party management tests, begin
  $0="hero party management tests"
  assert(room in active party == 3)
  add hero(hero:Helga)
  add hero(hero:Olaf)
  add hero(hero:Frumpy)
  assert(room in active party == 0)
  assert(hero by rank(0) == hero:Freki)
  assert(hero by rank(1) == hero:Helga)
  assert(hero by rank(2) == hero:Olaf)
  assert(hero by rank(3) == hero:Frumpy)
  # with a full party, hero by rank and hero by slot should returnt he same values
  assert(hero by rank(0) == hero by slot(0))
  assert(hero by rank(1) == hero by slot(1))
  assert(hero by rank(2) == hero by slot(2))
  assert(hero by rank(3) == hero by slot(3))
  # now delete the leader
  delete hero(hero:Freki)
  assert(room in active party == 1)
  assert(hero by rank(0) == 1)
  assert(hero by rank(1) == 2)
  assert(hero by rank(2) == 3)
  assert(hero by rank(3) == -1)
  assert(hero by slot(0) == -1)
  assert(hero by slot(1) == 1)
  assert(hero by slot(2) == 2)
  assert(hero by slot(3) == 3)
  # add a different leader
  add hero(hero:Styrge)
  assert(hero by slot(0) == hero:Styrge)
  # test find hero
  assert(find hero(hero:Freki)  == -1)
  assert(find hero(hero:Helga)  == 1)
  assert(find hero(hero:Olaf)   == 2)
  assert(find hero(hero:Frumpy) == 3)
  assert(find hero(hero:Styrge) == 0)
  # test rank in caterpillar
  assert(rank in caterpillar(hero:Freki)  == -1)
  assert(rank in caterpillar(hero:Helga)  == 1)
  assert(rank in caterpillar(hero:Olaf)   == 2)
  assert(rank in caterpillar(hero:Frumpy) == 3)
  assert(rank in caterpillar(hero:Styrge) == 0)
  # Add a hero to the reserve
  add hero(hero:Kitt)
  assert(room in active party == 0)
  variable(slot)
  slot := find hero(hero:Kitt)
  assert(slot >= 4)
  assert(rank in caterpillar(hero:Kitt) == -1)
  assert(hero by slot(slot) == hero:Kitt) # this command needs to work on reserve slots
  assert(hero by rank(4) == -1) # this command should not work on reserve slots
  # names
  $1="Styrge"
  get hero name(2, 0)
  assert(string compare(1, 2))
  $1="Helga"
  get hero name(2, 1)
  assert(string compare(1, 2))
  $1="Olaf"
  get hero name(2, 2)
  assert(string compare(1, 2))
  $1="Frumpy"
  get hero name(2, 3)
  assert(string compare(1, 2))
  $1="Kitt"
  get hero name(2, find hero(hero:Kitt))
  assert(string compare(1, 2))
  $1="Kittzilla"
  set hero name(1, find hero(hero:Kitt))
  get hero name(2, find hero(hero:Kitt))
  assert(string compare(1, 2))
  # Swapping
  swap out hero(hero:Helga)
  assert(hero by slot(1) == -1)
  assert(find hero(hero:Helga) >= 4)
  swap in hero(hero:Kitt)
  assert(hero by slot(1) == hero:Kitt)
  assert(find hero(hero:Kitt) >> 0 && find hero(hero:Kitt) <= 3)
  swap by position(0, 3) # swap Styrge and Frumpy
  assert(hero by slot(0) == hero:Frumpy)
  assert(hero by slot(3) == hero:Styrge)
  swap by position(3, find hero(hero:Helga)) # swap Styrge and Helga
  assert(hero by slot(3) == hero:Helga)
  assert(find hero(hero:Styrge) >= 4)
  swap by name(hero:Kitt, hero:Styrge)
  assert(hero by slot(1) == hero:Styrge)
  assert(find hero(hero:Kitt) >= 4)
  swap out hero(hero by slot(0)) # swap out frumpy
  assert(hero by slot(0) == -1)
  # restore numeric order
  add hero(hero:Freki) # Freki
  assert(hero by slot(0) == hero:Freki)
  swap by position(1, find hero(hero:Helga))
  assert(hero by slot(1) == hero:Helga)
  swap by position(2, find hero(hero:Olaf))
  assert(hero by slot(2) == hero:Olaf)
  swap by position(3, find hero(hero:Frumpy))
  assert(hero by slot(3) == hero:Frumpy)
end

## Party management
#lock hero (who)
#unlock hero (who)

script, hero caterpillar tests, begin
  variable(i)
  $0="hero caterpillar tests"

  $10="leader, cater=ON"
  do hero cater tests(me)
  
  suspend caterpillar
  for(i, 0, 3) do(
    $10="hero "
    append number(10, i)
    $10=", cater=OFF"
    do hero cater tests(i)
  )
  resume caterpillar
  $10=""

end

script, do hero cater tests, who, begin
  variable(d)
  walk hero to x (who, 8), w
  wait for hero(who)
  assert(hero x(who) == 8)
  walk hero to y(who, 10), w
  wait for hero(who)
  assert(hero y(who) == 10)
  walk hero to x(who, 9), w
  wait for hero(who)
  assert(hero x(who) == 9)
  walk hero to y(who, 8), w
  wait for hero(who)
  assert(hero y(who) == 8)
  walk hero to x (who, 6), w
  wait for hero(who)
  assert(hero x(who) == 6)
  set hero position(who, 7, 7), w
  assert(hero x(who) == 7)
  assert(hero y(who) == 7)
  walk hero(who, south, 2)
  wait for hero(who), w
  assert(hero y(who) == 9)
  assert(hero direction(who) == south)
  walk hero(who, west, 2)
  wait for hero(who), w
  assert(hero x(who) == 5)
  assert(hero direction(who) == west)
  walk hero(who, north, 1)
  wait for hero(who), w
  assert(hero y(who) == 8)
  assert(hero direction(who) == north)
  walk hero(who, east, 1)
  wait for hero(who), w
  assert(hero x(who) == 6)
  assert(hero direction(who) == east)
  # spin
  for(d, north, west) do(
    set hero direction(who, d), w
    assert(hero direction(who) == d)
  )
  # moonwalk
  for(d, north, west) do(
    walk hero(who, ((d + 2) ,mod, 4))
    set hero direction(who, d)
    wait for hero(who), w
    assert(hero direction(who) == d)
  )
  # walk into wall
  walk hero(who, north, 3) # should only make it 2 tiles
  wait for hero(who)
  assert(hero Y(who) == 6)
  # check walls
  expect hero walls(who, true, false, false, false)
  walk hero(who, west, 1)
  wait for hero(who), w
  walk hero(who, north, 1)
  wait for hero(who), w
  expect hero walls(who, false, true, false, false)
  walk hero(who, north, 2)
  wait for hero(who), w
  walk hero(who, east, 1)
  wait for hero(who), w
  expect hero walls(who, false, false, true, false)
  walk hero(who, east, 5)
  wait for hero(who), w
  expect hero walls(who, true, true, false, false)
  # speed test time!
  set hero speed(who, 2)
  assert(get hero speed(who) == 2)
  walk hero(who, south, 1)
  w(9), assert(hero is walking(who))
  w(1), assert(hero is walking(who) == false)
  set hero speed(who, 4)
  assert(get hero speed(who) == 4)
  walk hero(who, south, 1)
  w(4), assert(hero is walking(who))
  w(1), assert(hero is walking(who) == false)
  set hero speed(who, 5)
  assert(get hero speed(who) == 5)
  walk hero(who, south, 1)
  w(3), assert(hero is walking(who))
  w(1), assert(hero is walking(who) == false)
  set hero speed(who, 10)
  assert(get hero speed(who) == 10)
  walk hero(who, south, 1)
  w(1), assert(hero is walking(who))
  w(1), assert(hero is walking(who) == false)
  set hero speed(who, 20)
  assert(get hero speed(who) == 20)
  walk hero(who, south, 1)
  w(1), assert(hero is walking(who) == false)
  walk hero(who, west, 1), w
  walk hero(who, north, 2), w(2)
  assert(hero x(who) == 10)
  assert(hero y(who) == 6)
  set hero speed(who)
  assert(get hero speed(who) == 4)
  walk hero(who, west, 3)
  wait for hero(who)
  #FIXME: should probably test misaligned walking too
  # frame
  variable(fr)
  for(fr, 1, 8) do(
    set hero frame(who, (fr ,mod, 2))
    assert(hero frame(who) == (fr ,mod, 2))
    w(fr)
  )
  #pixel pos
  variable(px, py)
  px := hero pixel x(who)
  assert(px == 140)
  py := hero pixel y(who)
  assert(py == 120)
  variable(ix, iy)
  for(iy, 0, 5) do(
    for(ix, 0, 5) do(
      put hero(who, 105 + ix, 105 + iy)
      assert(hero pixel x(who) == 105 + ix)
      assert(hero pixel y(who) == 105 + iy)
      w
    )
  )
  put hero(who, px, py), w
    
end

script, expect hero walls, who, wn, we, ws, ww, begin
  assert(check hero wall(who, north) == wn)
  assert(check hero wall(who, east) == we)
  assert(check hero wall(who, south) == ws)
  assert(check hero wall(who, west) == ww)
end

## caterpillar
#suspend hero walls
#resume hero walls
#set hero frame (who, frame)
#set hero speed (who, speed)
#set hero z (who, z)

script, hero exp and levels tests, begin
  variable(i)
  $0="hero exp and levels tests"
  assert(experience to level(1) == 30)
  assert(experience to level(2) == 71)
  assert(experience to level(3) == 125)
  assert(experience to level(4) == 195)
  assert(experience to level(5) == 284)
  assert(experience to level(6) == 396)
  assert(experience to level(7) == 535)
  assert(experience to level(8) == 707)
  assert(experience to level(9) == 918)
  assert(experience to level(10) == 1176)
  assert(experience to level(11) == 1491)
  assert(experience to level(12) == 1874)
  assert(experience to level(13) == 2339)
  assert(experience to level(14) == 2902)
  assert(experience to level(15) == 3583)
  assert(experience to level(99) == 50183838)
  assert(get hero level(0) == 0)
  # level setting
  for(i, 1, 99) do(
    set hero level(0, i)
    assert(get hero level(0) == i)
    assert(total experience(0) == experience to level(i))
  )
  # level-based spell learning/forgetting
  set hero level(0, 9)
  assert(knows spell (0, 2) == false) # Freki should not have L.10 Wolf at level 9
  set hero level(0, 10)
  assert(knows spell (0, 2) == true) # Freki should learn L.10 Wolf at level 10
  set hero level(0, 0, false)
  assert(get hero level(0) == 0)
  assert(hero levelled(0) == -10)
  assert(knows spell (0, 2) == true) # Freki should not forget L.10 Wolf because of how we deleveled
  update level up learning(0, true)
  assert(knows spell (0, 2) == false) # Now Freki should forget L.10 Wolf.
  # experience
  assert(experience to next level(0) == 30)
  give experience(0, 5)
  assert(hero levelled(0) == 0)
  assert(experience to next level(0) == 25)
  give experience(0, 25)
  assert(get hero level(0) == 1)
  assert(hero levelled(0) == 1)
  assert(experience to next level(0) == 41)
  give experience(0, -1) # de-level should not work with this command, but experience will go down
  assert(get hero level(0) == 1)
  assert(hero levelled(0) == 0)
  assert(experience to next level(0) == 42)
  give experience(0, 42)
  assert(get hero level(0) == 2)
  assert(hero levelled(0) == 1)
  set hero level(0, 9)
  give experience(0, experience to next level(0))
  assert(get hero level(0) == 10)
  assert(hero levelled(0) == 1)
  assert(spells learned(0, get count) == 1)
  assert(spells learned(0, 0) == 2)
  assert(spells learnt(0, 0) == 1) #deprecated, but why not test it?
  give experience(0, 1) # should not cause levelling
  assert(hero levelled == 0)
  assert(spells learned(0, get count) == 0)
  # split experience
  set hero level(0, 0, true)
  give experience(party, 30)
  assert(hero levelled(0) == 0)
  assert(total experience(0) == 8)
  assert(total experience(1) == 8)
  assert(total experience(2) == 8)
  assert(total experience(3) == 8)
  give experience(party, 88)
  assert(get hero level(0) == 1)
  assert(get hero level(1) == 1)
  assert(get hero level(2) == 1)
  assert(get hero level(3) == 1)
  assert(total experience(find hero(hero:Kitt)) == 0) # outside of the party
  # experience for dead heroes
  set hero level(0, 0, true)
  set hero level(1, 0, true)
  set hero level(2, 0, true)
  set hero level(3, 0, true)
  set hero stat(2, 0, 0) # kill Olaf
  set dead heroes gain experience (false)
  give experience(party, 120)
  assert(total experience(0) == 40)
  assert(total experience(1) == 40)
  assert(total experience(2) == 0)
  assert(total experience(3) == 40)
  set hero level(0, 0, true)
  set hero level(1, 0, true)
  set hero level(2, 0, true)
  set hero level(3, 0, true)
  set dead heroes gain experience (true)
  give experience(party, 120)
  assert(total experience(0) == 30)
  assert(total experience(1) == 30)
  assert(total experience(2) == 30)
  assert(total experience(3) == 30)
  set hero level(0, 0, true)
  set hero level(1, 0, true)
  set hero level(2, 0, true)
  set hero level(3, 0, true)
  set hero stat(2, 0, get hero stat(2, 0, maximum stat)) # revive Olaf
  # level caps
  set hero level(0, 1)
  assert(get level cap == 99)
  set level cap(2)
  assert(get level cap == 2)
  give experience(0, 41)
  assert(get hero level(0) == 2)
  assert(total experience(0) == 71)
  assert(experience to next level(0) == 54) # being at the level cap does not alter the exp to next level
  give experience(0, 10000000)
  assert(hero levelled(0) == 0)
  assert(get hero level(0) == 2)
  set level cap(99)
  # reset
  set hero level(0, 0, true)
  set hero level(1, 0, true)
  set hero level(2, 0, true)
  set hero level(3, 0, true)
end

script, hero stat growth test, begin
  $0="hero stat growth test"
  show string(0), w
  # This tests the crappy default stat growth curve, which we will hopefully replace someday
  variable(i)
  for(i, 0, 99) do(
    set hero level(0 ,0)
    assert(get hero stat(0, 0, maximum stat) == 10)
    set hero level(0 ,1)
    assert(get hero stat(0, 0, maximum stat) == 13)
    set hero level(0 ,2)
    assert(get hero stat(0, 0, maximum stat) == 16)
    set hero level(0 ,3)
    assert(get hero stat(0, 0, maximum stat) == 19)
    set hero level(0 ,4)
    assert(get hero stat(0, 0, maximum stat) == 23)
    set hero level(0 ,5)
    assert(get hero stat(0, 0, maximum stat) == 26)
    set hero level(0 ,6)
    assert(get hero stat(0, 0, maximum stat) == 30)
    set hero level(0 ,7)
    assert(get hero stat(0, 0, maximum stat) == 34)
    set hero level(0 ,8)
    assert(get hero stat(0, 0, maximum stat) == 38)
    set hero level(0 ,9)
    assert(get hero stat(0, 0, maximum stat) == 42)
    set hero level(0 ,10)
    assert(get hero stat(0, 0, maximum stat) == 46)
    set hero level(0 ,11)
    assert(get hero stat(0, 0, maximum stat) == 50)
    set hero level(0 ,12)
    assert(get hero stat(0, 0, maximum stat) == 55)
    set hero level(0 ,13)
    assert(get hero stat(0, 0, maximum stat) == 60)
    set hero level(0 ,14)
    assert(get hero stat(0, 0, maximum stat) == 64)
    set hero level(0 ,15)
    assert(get hero stat(0, 0, maximum stat) == 69)
    set hero level(0 ,16)
    assert(get hero stat(0, 0, maximum stat) == 75)
    set hero level(0 ,17)
    assert(get hero stat(0, 0, maximum stat) == 80)
    set hero level(0 ,18)
    assert(get hero stat(0, 0, maximum stat) == 85)
    set hero level(0 ,19)
    assert(get hero stat(0, 0, maximum stat) == 91)
    set hero level(0 ,20)
    assert(get hero stat(0, 0, maximum stat) == 96)
    set hero level(0 ,21)
    assert(get hero stat(0, 0, maximum stat) == 102)
    set hero level(0 ,22)
    assert(get hero stat(0, 0, maximum stat) == 108)
    set hero level(0 ,23)
    assert(get hero stat(0, 0, maximum stat) == 114)
    set hero level(0 ,24)
    assert(get hero stat(0, 0, maximum stat) == 121)
    set hero level(0 ,25)
    assert(get hero stat(0, 0, maximum stat) == 127)
    set hero level(0 ,26)
    assert(get hero stat(0, 0, maximum stat) == 134)
    set hero level(0 ,27)
    assert(get hero stat(0, 0, maximum stat) == 140)
    set hero level(0 ,28)
    assert(get hero stat(0, 0, maximum stat) == 147)
    set hero level(0 ,29)
    assert(get hero stat(0, 0, maximum stat) == 154)
    set hero level(0 ,30)
    assert(get hero stat(0, 0, maximum stat) == 161)
    set hero level(0 ,31)
    assert(get hero stat(0, 0, maximum stat) == 168)
    set hero level(0 ,32)
    assert(get hero stat(0, 0, maximum stat) == 176)
    set hero level(0 ,33)
    assert(get hero stat(0, 0, maximum stat) == 183)
    set hero level(0 ,34)
    assert(get hero stat(0, 0, maximum stat) == 191)
    set hero level(0 ,35)
    assert(get hero stat(0, 0, maximum stat) == 199)
    set hero level(0 ,36)
    assert(get hero stat(0, 0, maximum stat) == 207)
    set hero level(0 ,37)
    assert(get hero stat(0, 0, maximum stat) == 215)
    set hero level(0 ,38)
    assert(get hero stat(0, 0, maximum stat) == 223)
    set hero level(0 ,39)
    assert(get hero stat(0, 0, maximum stat) == 232)
    set hero level(0 ,40)
    assert(get hero stat(0, 0, maximum stat) == 240)
    set hero level(0 ,41)
    assert(get hero stat(0, 0, maximum stat) == 249)
    set hero level(0 ,42)
    assert(get hero stat(0, 0, maximum stat) == 258)
    set hero level(0 ,43)
    assert(get hero stat(0, 0, maximum stat) == 267)
    set hero level(0 ,44)
    assert(get hero stat(0, 0, maximum stat) == 276)
    set hero level(0 ,45)
    assert(get hero stat(0, 0, maximum stat) == 285)
    set hero level(0 ,46)
    assert(get hero stat(0, 0, maximum stat) == 295)
    set hero level(0 ,47)
    assert(get hero stat(0, 0, maximum stat) == 304)
    set hero level(0 ,48)
    assert(get hero stat(0, 0, maximum stat) == 314)
    set hero level(0 ,49)
    assert(get hero stat(0, 0, maximum stat) == 324)
    set hero level(0 ,50)
    assert(get hero stat(0, 0, maximum stat) == 334)
    set hero level(0 ,51)
    assert(get hero stat(0, 0, maximum stat) == 344)
    set hero level(0 ,52)
    assert(get hero stat(0, 0, maximum stat) == 354)
    set hero level(0 ,53)
    assert(get hero stat(0, 0, maximum stat) == 365)
    set hero level(0 ,54)
    assert(get hero stat(0, 0, maximum stat) == 375)
    set hero level(0 ,55)
    assert(get hero stat(0, 0, maximum stat) == 386)
    set hero level(0 ,56)
    assert(get hero stat(0, 0, maximum stat) == 397)
    set hero level(0 ,57)
    assert(get hero stat(0, 0, maximum stat) == 408)
    set hero level(0 ,58)
    assert(get hero stat(0, 0, maximum stat) == 419)
    set hero level(0 ,59)
    assert(get hero stat(0, 0, maximum stat) == 430)
    set hero level(0 ,60)
    assert(get hero stat(0, 0, maximum stat) == 442)
    set hero level(0 ,61)
    assert(get hero stat(0, 0, maximum stat) == 453)
    set hero level(0 ,62)
    assert(get hero stat(0, 0, maximum stat) == 465)
    set hero level(0 ,63)
    assert(get hero stat(0, 0, maximum stat) == 477)
    set hero level(0 ,64)
    assert(get hero stat(0, 0, maximum stat) == 489)
    set hero level(0 ,65)
    assert(get hero stat(0, 0, maximum stat) == 501)
    set hero level(0 ,66)
    assert(get hero stat(0, 0, maximum stat) == 513)
    set hero level(0 ,67)
    assert(get hero stat(0, 0, maximum stat) == 526)
    set hero level(0 ,68)
    assert(get hero stat(0, 0, maximum stat) == 538)
    set hero level(0 ,69)
    assert(get hero stat(0, 0, maximum stat) == 551)
    set hero level(0 ,70)
    assert(get hero stat(0, 0, maximum stat) == 564)
    set hero level(0 ,71)
    assert(get hero stat(0, 0, maximum stat) == 577)
    set hero level(0 ,72)
    assert(get hero stat(0, 0, maximum stat) == 590)
    set hero level(0 ,73)
    assert(get hero stat(0, 0, maximum stat) == 604)
    set hero level(0 ,74)
    assert(get hero stat(0, 0, maximum stat) == 617)
    set hero level(0 ,75)
    assert(get hero stat(0, 0, maximum stat) == 631)
    set hero level(0 ,76)
    assert(get hero stat(0, 0, maximum stat) == 644)
    set hero level(0 ,77)
    assert(get hero stat(0, 0, maximum stat) == 658)
    set hero level(0 ,78)
    assert(get hero stat(0, 0, maximum stat) == 672)
    set hero level(0 ,79)
    assert(get hero stat(0, 0, maximum stat) == 686)
    set hero level(0 ,80)
    assert(get hero stat(0, 0, maximum stat) == 701)
    set hero level(0 ,81)
    assert(get hero stat(0, 0, maximum stat) == 715)
    set hero level(0 ,82)
    assert(get hero stat(0, 0, maximum stat) == 730)
    set hero level(0 ,83)
    assert(get hero stat(0, 0, maximum stat) == 745)
    set hero level(0 ,84)
    assert(get hero stat(0, 0, maximum stat) == 759)
    set hero level(0 ,85)
    assert(get hero stat(0, 0, maximum stat) == 774)
    set hero level(0 ,86)
    assert(get hero stat(0, 0, maximum stat) == 790)
    set hero level(0 ,87)
    assert(get hero stat(0, 0, maximum stat) == 805)
    set hero level(0 ,88)
    assert(get hero stat(0, 0, maximum stat) == 820)
    set hero level(0 ,89)
    assert(get hero stat(0, 0, maximum stat) == 836)
    set hero level(0 ,90)
    assert(get hero stat(0, 0, maximum stat) == 852)
    set hero level(0 ,91)
    assert(get hero stat(0, 0, maximum stat) == 868)
    set hero level(0 ,92)
    assert(get hero stat(0, 0, maximum stat) == 884)
    set hero level(0 ,93)
    assert(get hero stat(0, 0, maximum stat) == 900)
    set hero level(0 ,94)
    assert(get hero stat(0, 0, maximum stat) == 916)
    set hero level(0 ,95)
    assert(get hero stat(0, 0, maximum stat) == 933)
    set hero level(0 ,96)
    assert(get hero stat(0, 0, maximum stat) == 949)
    set hero level(0 ,97)
    assert(get hero stat(0, 0, maximum stat) == 966)
    set hero level(0 ,98)
    assert(get hero stat(0, 0, maximum stat) == 983)
    set hero level(0 ,99)
    assert(get hero stat(0, 0, maximum stat) == 1000)
  )
  set hero level(0, 0, true)
  show no value, w
end

########################################################################

script, npc tests, begin
  npc movement tests(1)
  npc movement tests(NPC reference(1))
end

script, npc movement tests, n, begin
  $0="npc movement tests"
  $10="n=", append number(10, n)
  show string(0)
  
  # assert starting pos
  assert(npc X(n) == 3)
  assert(npc Y(n) == 5)
  # walk in a circle, testing speed
  set npc speed(n, 4)
  walk npc(n, south, 1), w
  wait for npc(n)
  assert(npc Y(n) == 6)
  set NPC speed(n, 5)
  walk npc(n, east, 1), w
  wait for npc(n)
  assert(npc X(n) == 4)
  set NPC speed(n, 10)
  walk npc(n, north, 1), w
  wait for npc(n)
  assert(npc Y(n) == 5)
  set NPC speed(n, 2)
  walk npc(n, west, 1), w
  wait for npc(n)
  assert(npc X(n) == 3)
  set npc speed(n, 4)
  
  set npc position(n, 3, 5)
  
  show no value
end

########################################################################

script, menu tests, begin
  $0="menu tests"
  variable(i, m, mi, main, m1)
  m := create menu, w
  if(get menu id(m) <> -1) then($0="get menu id should have reported -1 for script-generated menu", crash)
  
  mi := add menu item(m), w
  $1="Puppies"
  set menu item caption(mi, 1), w
  mi := add menu item(m), w
  $1="Kittens"
  set menu item caption(mi, 1), w
  mi := add menu item(m), w
  $1="Walruses"
  set menu item caption(mi, 1), w
  mi := add menu item(m), w
  $1="Octopus"
  set menu item caption(mi, 1), w
  mi := add menu item(m), w
  $1="Plip"
  set menu item caption(mi, 1), w

  main := open menu, w
  bring menu forward(bottom menu), w

  for(i, align:left, align:right) do(
    set menu anchor x(m, i), w
    if(get menu anchor x(m) <> i) then($0="menu anchor x", crash)
    set menu anchor y(m, i), w
    if(get menu anchor y(m) <> i) then($0="menu anchor y", crash)
  )

  $1="Puppies"
  mi := find menu item caption(m, 1)
  if(mi == 0) then($0="failed to find first menu item by caption", crash)
  get menu item caption(mi, 2)
  if(not(string compare(1, 2))) then($0="found menu item that was not puppies", crash)

  $1="Walruses"
  mi := find menu item caption(m, 1)
  get menu item caption(mi, 2)
  if(not(string compare(1, 2))) then($0="found menu item that was not walruses", crash)
  
  mi := find menu item caption(m, 1, mi) #search for Walruses starting after Walruses
  if(mi <> 0) then($0="find menu item walrus should have failed", crash)

  mi := add menu item(m)
  $1="Kittens"
  set menu item caption(mi, 1), w

  variable(kitten1, kitten2, walruses)
  #search for Kitten from top
  $1="Kittens"
  kitten1 := find menu item caption(m, 1)
  #search for Kitten starting after Walruses
  $2="Walruses"
  walruses := find menu item caption(m, 2) 
  kitten2 := find menu item caption(m, 1, walruses) 
  if(kitten1 == 0) then($0="failed to find first kitten", crash)
  if(kitten2 == 0) then($0="failed to find second kitten", crash)
  get menu item caption(kitten1, 2)
  if(not(string compare(1, 2))) then($0="found menu item that was not kitten(1)", crash)
  get menu item caption(kitten2, 2)
  if(not(string compare(1, 2))) then($0="found menu item that was not kitten(2)", crash)
  if(kitten1 == kitten2) then($0="found the same kitten twice", crash)

  mi := add menu item(m), w
  delete menu item(mi), w
  $1="Kittens"
  mi := find menu item caption(m, 1)
  delete menu item(mi), w
  mi := first menu item(m)
  delete menu item(mi), w

  if(find menu ID(1) <> 0) then($0="found unopened menu", crash)
  open menu(1),w
  m1 := find menu ID(1)
  if(get menu ID(m1) <> 1) then($0="get menu ID mismatch vs find menu", crash)
  if(m1 == 0) then($0="failed to find opened menu", crash)  
  close menu(m1),w

  for(i, -3, 12) do(
    set menu border(main, i), w
  )
  if(get menu border(main) <> 12) then($0="readback of menu border thickness failed", crash)
  for(i, 0, 10) do(
    set menu boxstyle(main, i)
  )
  if(get menu boxstyle(main) <> 10) then($0="readback of menu boxstyle failed", crash)

  for(i, 0, 15) do(
    set menu max chars(main, i), w
    if(get menu max chars(main) <> i) then($0="readback of menu max chars failed", crash)
  )
  set menu max chars(main, 0), w
  for(i, 10, 30) do(
    set menu min chars(main, i), w
    if(get menu min chars(main) <> i) then($0="readback of menu min chars failed", crash)
  )
  set menu min chars(main, 0), w

  for(i, -50, 50, 10) do(
    set menu offset x(main, i), w
    if(get menu offset x(main) <> i) then($0="readback of menu offset x failed", crash)
    set menu offset y(main, i), w
    if(get menu offset y(main) <> i) then($0="readback of menu offset y failed", crash)
  )
  set menu offset x(main, 0)
  set menu offset y(main, 0)
  for(i, align:left, align:right) do(
    set menu anchor x(main, i), w
    if(get menu anchor x(main) <> i) then($0="readback of menu anchor x failed", crash)
    set menu anchor y(main, i), w
    if(get menu anchor y(main) <> i) then($0="readback of menu anchor y failed", crash)
  )
  set menu anchor x(main, 0), w
  set menu anchor y(main, 0), w

  for(i, align:left, align:right) do(
    set menu text align(main, i), w
    if(get menu text align(main) <> i) then($0="readback of menu text align failed", crash)
  )
  set menu text align(main, 0), w

  set menu bit(main, 0, true), w  #Transparent box
  if(get menu bit(main, 0) <> true) then($0="failed to set menu bit", crash)
  set menu bit(main, 0, false), w #Opaque box
  if(get menu bit(main, 0) <> false) then($0="failed to unset menu bit", crash)
  variable(save rows)
  save rows := get menu max rows(main)
  set menu max rows(main, 3), w
  set menu bit(main, 1, true), w  #never show scrollbar
  set menu bit(main, 1, false), w #show scrollbar
  set menu max rows(main, save rows)
  set menu bit(main, 4, true), w  #no box
  set menu bit(main, 4, false), w #show box
  set menu bit(main, 8, true), w  #Advance text box when menu closes
  show text box(6), w
  if(not(menu is open(main))) then($0="why isn't the main menu open?", crash)
  close menu(top menu), w
  close menu(main), w
  if(current text box <> -1) then($0="menu bit failed to close textbox", crash)

  if(menu is open(main)) then($0="why is the main menu still open?", crash)

  variable(antelope, buffalo, catbus, duiker)
  m := create menu, w
  antelope := add menu item(m), $0="Antelope", set menu item caption(antelope, 0), w
  buffalo  := add menu item(m), $0="Buffalo",  set menu item caption(buffalo, 0), w
  catbus   := add menu item(m), $0="Catbus",   set menu item caption(catbus, 0), w
  duiker   := add menu item(m), $0="Duiker",   set menu item caption(duiker, 0), w

  # Hide when disabled 
  set menu item bit(catbus, 0, true), w
  if(get menu item bit(catbus, 0) <> true) then($0="menu item bit readback failed", crash)
  # Disable now
  set menu item type(catbus, menutype:label)
  set menu item subtype(catbus, 1), w
  # Don't hide
  set menu item bit(catbus, 0, false), w
  # Re-enable
  set menu item subtype(catbus, 0), w

  set menu item settag(catbus, 3)
  if(get menu item settag(catbus) <> 3) then($0="menu item settag readback failed", crash)
  if(check tag(3)) then($0="tag 3 shouldn't be on yet (menu)", crash)
  use menu item(catbus), w
  if(not(check tag(3))) then($0="tag 3 shouldn't be on now (menu)", crash)
  set menu item settag(catbus, 0)
  set menu item togtag(catbus, 3)
  use menu item(catbus), w
  if(check tag(3)) then($0="tag 3 should be toggled off (menu)", crash)
  use menu item(catbus), w
  if(check tag(3)==OFF) then($0="tag 3 should be toggled on (menu)", crash)
  use menu item(catbus), w
  if(check tag(3)) then($0="tag 3 should be toggled off again (menu)", crash)
  set menu item togtag(catbus, 0)

  for(i, 1, 2) do(
    set menu item tag(catbus, -3, i), w
    if(get menu item tag(catbus, i) <> -3) then($0="menu item tag readback failed", crash)
    set tag(3, ON), w
    set menu item tag(catbus, 3, i), w
    set tag(3, OFF), w
    set menu item tag(catbus, 0, i), w
  )

  $0="menu item tag req", show string(0)
  for(i, 1, 2) do(
    set tag(3, OFF)
    if(get menu item tag(catbus, i) <> 0) then($0="menu item tag req should be zero:", append number(0, i), crash)
    set menu item tag(catbus, 3, i), w
    if(get menu item tag(catbus, i) <> 3) then($0="menu item tag req readback fail:", append number(0, i), crash)
    set tag(3, ON), w
    set menu item tag(catbus, -3, i), w
    set tag(3, OFF), w
    set menu item tag(catbus, 0, i), w
  )
  show no value
  
  for(i, 0, 2) do(
    set menu item extra(buffalo, i, (i + 1) * 10)
    if(get menu item extra(buffalo, i) <> (i + 1) * 10) then($0="menu item extra readback failed", crash)
  )
  
  set menu item type(catbus, menutype: special)
  $0="" # use default caption
  set menu item caption(catbus, 0), w
  for (i, 0, 13) do(
    set menu item subtype(catbus, i), w
  )
  $0="Catbus, not Save"
  set menu item caption(catbus, 0), w
  $0=""
  set menu item caption(catbus, 0), w
  set menu item type(catbus, menutype:menu), w
  for(i, 0, 2) do(
    set menu item subtype(catbus, i), w
    if(get menu item subtype(catbus) <> i) then($0="menu item subtype readback failed", crash)
  )
  $0="Catbus"
  set menu item caption(catbus, 0), w
  
  # open another menu
  set menu item type(catbus, menutype:menu)
  set menu item subtype(catbus, 2)
  use menu item(catbus), w
  if(get menu id(top menu) <> 2) then($0="Failed to open a menu from a menu", crash)
  close menu(top menu), w

  # open a text box
  set menu item type(catbus, menutype:textbox)
  set menu item subtype(catbus, 7)
  use menu item(catbus), w
  if(current textbox <> 7) then($0="Failed to open a text box from a menu", crash)
  advance text box, w

  if(get menu item type(catbus) <> menutype:textbox) then($0="menu item type readback failed", crash)
  set menu item type(catbus, menutype:label)

  # run a script from a menu
  set menu item type(catbus, menutype:script)
  set menu item subtype(catbus, @on menu item use)
  use menu item(catbus), w
  if(menu item script global <> 99) then($0="Failed to run a script from a menu", crash)

  variable(oldcol)
  oldcol := get menu textcolor(m)
  for(i, 0, 10) do(
    set menu textcolor(m, i * 13), w
    if(get menu textcolor(m) <> i * 13) then($0="menu textcolor readback failed", crash)
  )
  set menu textcolor(m, oldcol)

  # iterate all menu items
  variable(count)
  count := 0
  mi := first menu item(m)
  while(mi) do(
    count += 1
    mi := next menu item(mi)
  )
  if(count <> 4) then($0="iterated wrong number of menu items (all)")
  # now hide catbus
  set menu item bit(catbus, menu item bit:hide when disabled, true)
  set menu item tag(catbus, 3)
  set tag(3, OFF)
  # iterate all except hidden
  count := 0
  mi := first menu item(m)
  while(mi) do(
    count += 1
    mi := next menu item(mi, true)
  )
  if(count <> 3) then($0="iterated wrong number of menu items (vis only)")
  # iterate all including hidden
  count := 0
  mi := first menu item(m)
  while(mi) do(
    count += 1
    mi := next menu item(mi, false)
  )
  if(count <> 4) then($0="iterated wrong number of menu items (vis only)")


  # close when selected
  set menu item bit(antelope, 1, true)
  use menu item(antelope), w
  if(top menu == m) then($0="Even Toed Ungulate menu failed to close", crash)

  menu close global := 0
  m := create menu, w
  mi := add menu item(m)
  $1="close me"
  set menu item caption(mi, 1), w
  set menu item bit(mi, menu item bit:close menu when selected, true)
  set menu on close script(m, @on close menu test)
  if(get menu on close script(m) <> @on close menu test) then($0="menu close script readback failed", crash)
  use menu item(mi), w
  if(menu close global <> 99) then($0="menu close script didn't run", crash)

  menu scroll tests
end

script, on menu item use, begin
  menu item script global := 99
end

script, on close menu test, begin
  menu close global := 99
end


script, scroll through menu, menu, numitems, begin
  variable (i, j, mi)

  # test scrolling
  for (i, 1, 3, 2) do (
    set menu max rows(menu, i)
    # forwards
    mi := first menu item(menu)
    while (mi) do (
      select menu item(mi), w
      mi := next menu item(mi)
    )
    # backwards
    mi := menu item by slot(menu, numitems -- 1)
    while (mi) do (
      select menu item(mi), w
      mi := previous menu item(mi)
    )
    # randomly
    for (j, 0, 4) do (
      select menu item(menu item by slot(menu, random(0, numitems -- 1))), w
    )
  )
  set menu max rows(menu, 0)
end

script, menu scroll tests, begin
  $0="menu scroll tests"

  variable (main, mi, next, i, numitems)
  main := open menu, w
  set menu bit(main, 1, false), w #show scrollbar
  allow minimap(true), w #make sure there are no hidden items
  allow save anywhere(true), w

  # test menu item iteration
  mi := first menu item(main)
  while (mi) do (
    get menuitemcaption(mi,10)
    #trace(10)
    appendnumber(10, numitems)
    assert (menu item slot(mi) == numitems)
    assert (menu item by slot(main, numitems, true) == mi)
    assert (menu item by slot(main, numitems, false) == mi)
    assert (menu item true slot(mi) == numitems)
    assert (menu item by true slot(main, numitems) == mi)
    next := next menu item(mi, false)
    if (next) then (
      assert (mi == previous menu item(next))
    )
    set menu item extra(mi, 0, numitems)
    mi := next
    numitems += 1
  )
  $10=""

  # menu item iteration edge cases
  assert (previous menu item(first menu item(main)) == 0)
  assert (next menu item(menu item by slot(main, numitems -- 1)) == 0)
  assert (menu item by slot(main, numitems, true) == 0)
  assert (menu item by slot(main, numitems, false) == 0)
  assert (menu item by slot(main, -1) == 0)
  assert (menu item by true slot(main, -1) == 0)
  assert (menu item by true slot(main, numitems) == 0)

  # test "select menu item"
  mi := first menu item(main)
  while (mi) do (
    select menu item(mi), w
    assert (selected menu item(main) == mi)
    mi := next menu item(mi)
  )

  # test scrolling
  scroll through menu(main, numitems)

  # check hidden items sorted to end:
  # 1. hide three items
  set tag(3, OFF)
  variable(hidden1, hidden2, hidden3)
  hidden3 := menu item by slot(main, 4)
  set menu item bit(hidden3, menu item bit: hide when disabled, true)
  set menu item tag(hidden3, 3, 1)
  hidden1 := menu item by slot(main, 0)
  set menu item bit(hidden1, menu item bit: hide when disabled, true)
  set menu item tag(hidden1, 3, 1)
  hidden2 := menu item by slot(main, 3)
  set menu item bit(hidden2, menu item bit: hide when disabled, true)
  set menu item tag(hidden2, 3, 1)
  w

  # 2. add new item
  mi := add menu item(main)
  set menu item extra(mi, 0, numitems)
  numitems += 1
  $1="a new item!"
  set menu item caption(mi, 1), w

  # 3. check visible items in correct order
  variable (temp, extra, mi2)
  temp := -1
  for (i, 0, num items -- 3 -- 1) do (
    mi := menu item by slot(main, i, true)
    mi2 := menu item by slot(main, i, false)
    assert (mi == mi2)
    extra := get menu item extra(mi2, 0)
    if (extra <= temp) then ($0="menu items not in increasing order", crash)
    temp := extra
  )

  # 4. check hidden items at end in correct order
  if (menu item by slot(main, numitems -- 3, true) <> 0) then ($0="menuitembyslot returned hidden item", crash)
  if (menu item by slot(main, numitems -- 3, false) <> hidden1) then ($0="hidden items out of order", crash)
  if (menu item by slot(main, numitems -- 2, false) <> hidden2) then ($0="hidden items out of order", crash)
  if (menu item by slot(main, numitems -- 1, false) <> hidden3) then ($0="hidden items out of order", crash)
  assert (menu item by slot(main, numitems, false) == 0)

  # 5. check "true order" hasn't changed
  for (i, 0, num items -- 1) do (
    mi := menu item by true slot(main, i)
    assert (menu item true slot(mi) == i)
    assert (get menu item extra(mi, 0) == i)
  )

  # test scrolling again
  scroll through menu(main, numitems -- 3)

  # check unhidden menu items sorted back correctly
  set tag(3, ON), w
  for (i, 0, numitems -- 1) do (
    mi := menu item by slot(main, i, false)
    assert (mi == menu item by slot(main, i, true))
    assert (get menu item extra(mi, 0) == i)
  )

  close menu(main)
end

#next menu(menu handle)
#open menu (ID, allow duplicate)
#parent menu(menu item handle)
#previous menu(menu handle)
#swap menu items(handle1, handle2)
#wait for menu (menu handle)

########################################################################

script, textbox tests, begin
  $0="textbox tests"
  show text box(2), w
  advance text box, w
  show text box(3), w
  advance text box, w
  if(current textbox <> 4) then(crash)
  advance text box, w
  show text box(3), w
  advance text box, w
  if(current textbox <> 5) then(crash)
  advance text box, w
  if(current textbox <> -1) then(crash)
end

########################################################################

script, battle tests, begin
  # there are some other battle tests in with the timer tests
  $0="battle tests"
  show value(random(1, 999999999)), w
  force random battle
  show value(random(1, 999999999)), w # this should remain deterministic after battle
  show no value, w
end

script, force random battle, begin
  variable(s, x, y, d)
  # save hero state
  s := get hero speed(me)
  x := hero x(me)
  y := hero y(me)
  d := hero direction(me)
  # get the hero ready for forcing the battle
  set hero speed(0, 20)
  set hero position(0, 15, 9), w
  # force the battle
  walk hero(0, north, 1), w
  # restore hero state
  set hero speed(me, s)
  set hero position(me, x, y)
  set hero direction(me, d)
  w
end

script, force non random battle, begin
  w
  fight formation(0)
  w(2)
end

plotscript, after battle, begin
  $0="After battle script:"
  battle script sequence += 1
  append number(0, battle script sequence)
  trace(0)
  show string at(0, 0, 0)
  w
  hide string(0)
end

plotscript, instead of battle, form, begin
  $0="Instead of battle script("
  append number(0, form)
  $0+")"
  trace(0)
  w
  fight formation(form)
  $0="  finish instead of battle"
  trace(0)
end

########################################################################

script, timer tests, begin
  variable(i)
  
  allocate timers(32)
  set timer(31, 10, 1, @timer test 1, 1)
  show string at(1, 10, 10)
  w, w, w, w
  if(read timer(31) <> 6) then($0="read timer failed", crash)
  w(6), w

  timer global := 100
  set timer(31, 0, 1, @looping timer test, 1)
  w(11)
  
  $10="random"
  test timer and battle interactions(@force random battle)
  $10="fight formation"
  test timer and battle interactions(@force non random battle)
  $10=""

  
  $0="timer interactions with after battle", trace(0)
  teleport to map(1, 10, 8), w # after battle
  battle script sequence := 0
  test timer and battle interactions(@force random battle)
  if(battle script sequence <> 3) then($0="(ab) afterbattle should have happened 3 times", crash)

  $0="timer interactions with instead of battle", trace(0)
  teleport to map(2, 10, 8), w # instead of battle
  battle script sequence := 0
  test timer and battle interactions(@force random battle)
  if(battle script sequence <> 0) then($0="(ib) afterbattle should have happened 0 times", crash)

  $0="timer interactions with after battle + instead of battle", trace(0)
  teleport to map(3, 10, 8), w # after battle + instead of battle
  battle script sequence := 0
  test timer and battle interactions(@force random battle)
  if(battle script sequence <> 3) then($0="(ab+ib) afterbattle should have happened 3 times", crash)

  teleport to map(0, 10, 8), w

  hide string(1)
end

script, test timer and battle interactions, trigger battle, begin
  #regular timer
  timer global := 0
  timer global will become := 1000
  set timer(31, 10, 1, @battle timer test, -1, 0)
  run script by id(trigger battle)
  if(read timer(31) <= 0) then($0="timer should still be running", crash)
  if(timer global <> 0) then($0="timer global should still be zero", crash)
  w(10)
  if(read timer(31) >> 0) then($0="timer should be done by now", crash)
  if(timer global <> timer global will become) then($0="timer global didn't change", crash)
  
  #timerflag:battle
  timer global := 0
  timer global will become := 2000
  set timer(31, 10, 1, @battle timer test, 1, timerflag:battle)
  run script by id(trigger battle)
  if(read timer(31) >> 0) then($0="(bat) timer should be done by now", crash)
  if(timer global <> timer global will become) then($0="(bat) timer global didn't change", crash)

  #timerflag:battle ,or, timerflag:critical
  timer global := 0
  timer global will become := 3000
  set timer(31, 10, 1, @battle timer test, 1, (timerflag:battle,or,timerflag:critical))
  set timer(30, 20, 1, @battle timer test, 0, (timerflag:battle))
  run script by id(trigger battle)
  if(read timer(31) >> 0) then($0="(bat+crit) timer should be done by now", crash)
  if(timer global <> timer global will become) then($0="(bat+crit) timer global didn't change", crash)
  timer global will become := 4000
  if(read timer(30) <= 0) then($0="(bat+crit) second timer should still be running", crash)
  w(12)
  if(read timer(30) >> 0) then($0="(bat+crit) second timer should be done by now", crash)
  if(timer global <> timer global will become) then($0="(bat+crit) timer global didn't change on second timer", crash)
  timer global := 0
  w
end

script, timer test 1, begin
  show value(12345)
  w
end

script, looping timer test, begin
  if(timer global <= 0) then(timer global := 0, exit script)
  set timer(31, 0, 1, @looping timer test, 1)
  timer global -= 10
  show value(timer global)
  _checkpoint
end

script, battle timer test, begin
  timer global := timer global will become
  $0="battle timer test:"
  append number(0, timer global)
  trace(0)
  show string(0), w
end

########################################################################

########################################################################
#### COMMANDS THAT STILL NEED TESTS
#allow minimap (setting)
#allow save anywhere (setting)
#alter NPC (who,NPCstat,value)
#value,and,value
#animation start tile (tile number, layer)
#any key
#append ascii (ID, char)
#append number (ID, number)
#ascii from string (ID, position)
#autonumber
#autosave
#begin,other commands,end
#Boolean Constants
#break
#camera follows hero (who)
#camera follows NPC (who)
#camera pixel X
#camera pixel Y
#cancel key
#cancel map name display
#case(value)
#center slice (handle)
#center string at (ID, x, y)
#change NPC ID (reference,new ID)
#change tileset (tileset, layer)
#check NPC wall (who, direction)
#check parentage (handle, parent handle)
#check tag (tag)
#child count (handle)
#clamp slice (handle1, handle2)
#clear string(ID)
#clone sprite (handle)
#color:blue
#Color Constants
#color:green
#color:red
#concatenate strings (dest, source)
#continue
#copy string (dest, source)
#create container (width, height)
#create ellipse (width, height, border color, fill color)
#create grid (width, height, rows, columns)
#create NPC (ID,X,Y,direction)
#create rect (width, height, style)
#create text
#crop
#current display tile (tile number, layer)
#current map
#current song
#current stat
#days of play
#decrement (variable,amount)
#default tile
#define constant (number,name)
#delete char (ID, position)
#delete enemy from formation (formation, slot)
#delete item (item,number)
#delete map state (whichdata)
#delete save (slot)
#destroy NPC (reference)
#Direction Constants
#dismount vehicle
#number / number
#do
#down
#down key
#draw NPCs above heroes (setting)
#east
#east wall
#eight
#else
#end
#number == number
#exit returning(value)
#exit script
#expand string(ID)
#number ^ power
#export globals (slot, first, last)
#extended scancodes enabled
#extract color(color, component)
#fade screen in
#fade screen out (red,green,blue)
#false
#fight formation (number)
#fill parent (handle, true_or_false)
#find colliding slice (parent, slice, number, check descendants)
#find enemy in formation (formation, enemy id, copy number)
#first child(handle)
#first container child(handle)
#first rect child(handle)
#first sprite child(handle)
#five
#focus camera (x,y,speed)
#for(counter,start,finish,step) do(commands)
#formation probability (formation set, formation)
#formation set frequency (formation set)
#formation slot enemy (formation, slot)
#formation slot x (formation, slot)
#formation slot y (formation, slot)
#four
#free slice (handle)
#free slice children (handle)
#free sprite (handle)
#game over
#get ambient music
#get attack name
#get bottom padding (handle)
#get color(index)
#get count
#get damage cap
#get death script
#get each step script
#get ellipse border col (handle)
#get ellipse fill col (handle)
#get enemy appearance (enemyid, appearance)
#get enemy name (enemyid, stringid)
#get enemy stat(enemy, stat)
#get foot offset
#get formation background (formation, background)
#get formation song (formation)
#get global string (ID, global)
#get grid columns (handle)
#get grid rows (handle)
#get instead of battle script
#get inventory size
#get item (item,number)
#get item name (ID, item)
#get left padding (handle)
#get load script
#get map edge mode
#get map name (ID, map)
#get map tileset
#get money (amount)
#get music volume
#get NPC ID (reference)
#get NPC ignores walls (who)
#get NPC moves (who)
#get NPC obstructs (who)
#get NPC usable (who)
#get on keypress script
#get outline(handle)
#get rect bgcol (handle)
#get rect border (handle)
#get rect fgcol (handle)
#get rect style (handle)
#get rect trans (handle)
#get right padding (handle)
#get slice clipping (handle)
#get slice extra (handle, extra)
#get slice lookup (handle)
#get slice velocity x (handle)
#get slice velocity y (handle)
#get slice visible (handle)
#get song name (ID, song)
#get sort order (handle)
#get sprite frame (handle)
#get sprite palette (handle)
#get sprite set number (handle)
#get sprite trans (handle)
#get sprite type (handle)
#get text bg(handle)
#get text color(handle)
#get tile animation offset (animation pattern, layer)
#get top padding (handle)
#get victory music
#get wrap(handle)
#get zone extra (zone id, extra num)
#get zone name (string id, zone id)
#globals to string(ID, starting global, length)
#global variable (id,name)
#number >> number
#number >= number
#greyscale palette (first, last)
#grid is shown (handle)
#harm tile
#hide battle health meter (state)
#hide battle ready meter (state)
#hide string (ID)
#horiz flip sprite (handle, flip)
#hours of play
#if(condition) then(commands) else(commands)
#import globals (slot, first, last)
#include, filename
#increment (variable,amount)
#init mouse
#input string (ID, maxlength, use current, center, position x, position y)
#inside battle
#inventory (item)
#is filling parent (handle)
#item count in slot (slot)
#item in slot (slot)
#joystick axis (axis,multiplier,joystick)
#joystick button (button,joystick)
#Key Constants
#key is pressed (scancode)
#keyval (scancode)
#last ascii
#last child(handle)
#last formation
#last save slot
#layer tileset (layer)
#leader
#left
#left button
#left key
#number << number
#number <= number
#load attack sprite (num, palette)
#load backdrop sprite (num)
#load border sprite (num, palette)
#load from slot (slot)
#load hero sprite (num, palette)
#load large enemy sprite (num, palette)
#load map state (whichdata, customid)
#load medium enemy sprite (num, palette)
#load palette (palette number)
#load portrait sprite (num, palette)
#load slice collection (id)
#load small enemy sprite (num, palette)
#load tileset (tileset, layer)
#load walkabout sprite (num, palette)
#load weapon sprite (num, palette)
#value && value
#value || value
#value ^^ value
#lookup slice (lookup code, start slice)
#lose money (amount)
#map cure (attack, target, attacker)
#map height (map)
#map width (map)
#maximum stat
#me
#milliseconds
#minutes of play
#number,mod,number
#mouse button (which)
#mouse click (which)
#Mouse Constants
#mouse pixel X
#mouse pixel Y
#mouse region (x min, x max, y min, y max)
#move slice above (handle, above what handle)
#move slice below (handle, below what handle)
#move slice by (handle, relative x, relative y, ticks)
#move slice to (handle, x, y, ticks)
#number * number
#next container sibling(handle)
#next rect sibling(handle)
#next sibling(handle)
#next sprite sibling(handle)
#nine
#none
#north
#north wall
#not (value)
#number <> number
#NPC at pixel (x, y, number)
#NPC at spot (x, y, number)
#NPC copy count (ID)
#NPC direction (who)
#NPC extra (who, which)
#NPC frame (who)
#NPC is walking (who)
#NPC pixel X (who)
#NPC pixel Y (who)
#NPC reference (ID, copy)
#NPC X (who)
#NPC Y (who)
#number from string (ID, default)
#Numeric Constants
#off
#on
#one
#value,or,value
#order menu
#outside battle
#outside battle cure
#overhead tile
#pan camera (direction,distance,pixelstep)
#parent slice (handle)
#party
#party money
#pause sound (num)
#pay money (amount)
#place sprite
#play song (song)
#play sound (num,loop,preempt)
#plotscript, name, argumentnames (statements)
#positionstring (ID, x, y)
#previous sibling(handle)
#put camera (x,y)
#put mouse (X, Y)
#put npc (who,x,y)
#put slice (handle, X, Y)
#put slice screen (handle, x, y)
#put sprite (handle, x, y)
#random (lownumber, highnumber)
#random formation (formation set)
#read attack name (ID, attack)
#read color (index, element)
#read enemy data (enemyid, data)
#read global (id)
#read map block (x,y,layer)
#read NPC (who,NPCstat)
#read pass block (x,y)
#read timer (id)
#read zone (zone id, x, y)
#realign slice (handle, horiz align, vert align, horiz anchor, vert anchor)
#replace attack sprite (handle, num, palette)
#replace backdrop sprite (handle, num)
#replace border sprite (handle, num, palette)
#replace char (ID, position, char)
#replace hero sprite (handle, num, palette)
#replace large enemy sprite (handle, num, palette)
#replace medium enemy sprite (handle, num, palette)
#replace portrait sprite (handle, num, palette)
#replace small enemy sprite (handle, num, palette)
#replace walkabout sprite (handle, num, palette)
#replace weapon sprite (handle, num, palette)
#reset game
#reset map state (whichdata)
#reset palette
#resume box advance
#resume map music
#resume NPCs
#resume NPC walls
#resume obstruction
#resume overlay
#resume player
#resume random enemies
#resume random enemys
#resume timers
#return(value)
#RGB(red, green, blue)
#right
#right button
#right key
#run script by ID (id, argument1, argument2, argument3...)
#save in slot (slot)
#save map state (whichdata, customid)
#save menu (reallysave)
#save slot used (slot)
#script, name, argumentnames (statements)
#search string (ID1, ID2, start)
#seconds of play
#seed random (new seed)
#set ambient music (song)
#set battle wait mode (state)
#set bottom padding (handle, pixels)
#set caterpillar mode (state)
#set color(index, value)
#set damage cap (cap)
#set days of play (days)
#set death script (id)
#set debug keys disable (state)
#set each step script (id)
#set ellipse border col (handle, color)
#set ellipse fill col (handle, color)
#set enemy appearance (enemyid, appearance,value)
#set enemy name (enemyid, stringid)
#set enemy stat(enemy, stat, value)
#set foot offset (offset)
#set formation background (formation, background, animation frames, animation ticks)
#set formation song (formation, song)
#set grid columns (handle, columns)
#set grid rows (handle, rows)
#set harm tile damage (amount)
#set harm tile flash (color)
#set horiz align (handle, edge)
#set horiz anchor (handle, edge)
#set hours of play (hours)
#set inn no revive mode (state)
#set instead of battle script (id)
#set inventory size (new size)
#set item count in slot (slot, count)
#set item in slot (slot, item)
#set left padding (handle, pixels)
#set load script (id)
#set map edge mode (mode, default tile)
#set minutes of play (min)
#set money (amount)
#set music volume (volume)
#set no HP level up restore (state)
#set no MP level up restore (state)
#set NPC direction (who, direction)
#set NPC extra (who, which, value)
#set NPC frame (who, frame)
#set NPC ignores walls (who, value)
#set NPC moves (who, value)
#set NPC obstructs (who, value)
#set NPC position (who, X, Y)
#set NPC speed (who, speed)
#set NPC usable (who, value)
#set on keypress script (id)
#set outline(handle, outline)
#set padding (handle, pixels)
#set parent (handle, parent handle)
#set rect bgcol (handle, color)
#set rect border (handle, border)
#set rect fgcol (handle, color)
#set rect style (handle, style)
#set rect trans (handle, transparency setting)
#set right padding (handle, pixels)
#set seconds of play (sec)
#set slice clipping (handle, clip)
#set slice edge x (handle, edge, value)
#set slice edge y (handle, edge, value)
#set slice extra (handle, extra, value)
#set slice height (handle, height)
#set slice lookup (handle, code)
#set slice screen x (handle, x)
#set slice screen y (handle, y)
#set slice text(handle, string id)
#set slice velocity (handle, horiz pixels per tick, vert pixels per tick, ticks)
#set slice velocity x (handle, pixels per tick, ticks)
#set slice velocity y (handle, pixels per tick, ticks)
#set slice visible (handle, vis)
#set slice width (handle, width)
#set slice x (handle, X)
#set slice y (handle, Y)
#set sort order (handle, order)
#set sprite frame (handle, num)
#set sprite palette (handle, num)
#set sprite trans (handle, drawtransparent)
#set sprite visible
#set tag (tag,value)
#set text bg(handle, color)
#set text color(handle, color)
#set tile animation offset (animation pattern, offset, layer)
#set timer (id, count, speed, trigger, string, flags)
#set top padding (handle, pixels)
#variable := value
#set vert align (handle, edge)
#set vert anchor (handle, edge)
#set victory music (song)
#set wrap(handle, wrap)
#set zone extra (zone id, extra num, value)
#seven
#show backdrop (number)
#show grid (handle, shown)
#show map
#show mini map
#show no value
#show string (ID)
#show string at (ID, x, y)
#show value (number)
#sign (number)
#six
#slice at pixel (parent, x, y, number, check descendants)
#slice child (handle, number)
#slice collide (handle1, handle2)
#slice collide point (handle, x, y)
#slice contains (handle1, handle2)
#slice edge x (handle, edge)
#slice edge y (handle, edge)
#slice height (handle)
#slice is container (handle)
#slice is ellipse (handle)
#slice is grid (handle)
#slice is moving (handle)
#slice is rect (handle)
#slice is sprite (handle)
#slice is text (handle)
#slice is valid (id)
#slice screen x (handle)
#slice screen y (handle)
#slice to back (handle)
#slice to front (handle)
#slice width (handle)
#slice x (handle)
#slice y (handle)
#song: same as last map
#song: same as map
#song: silence
#sort children (handle, wipe)
#sound is playing (num)
#south
#south wall
#spells menu (who)
#sprite frame count (handle)
#sprite is horiz flipped (handle)
#sprite is vert flipped (handle)
#sprite layer
#sqrt (number)
#status screen (who)
#stop slice (handle)
#stop song
#stop sound (num)
#stop timer (id)
#string color (ID, foreground color, background color)
#string compare (ID1, ID2)
#string from textbox (ID, textbox, line, expand)
#string is visible (ID)
#string length (ID)
#string style (ID, style)
#string to globals (ID, starting global, length)
#string X (ID)
#string Y (ID)
#number -- number
#suspend box advance
#suspend catapillar
#suspend caterpillar
#suspend map music
#suspend NPCs
#suspend NPC walls
#suspend obstruction
#suspend overlay
#suspend player
#suspend random enemies
#suspend random enemys
#suspend timers
#switch(expression)
#system day
#system hour
#system minute
#system month
#system second
#system year
#team menu
#teleport to map (map, x, y)
#nine
#then
#three
#Tile Constants
#timer: default
#timer flag: battle
#timer flag: critical
#timer flag: menu
#timer: game over
#trace (string)
#trace value (expression, ...)
#trim string (ID, start, length)
#true
#tweak palette (red, green, blue, first, last)
#two
#up
#update palette
#up key
#use door (number)
#use item (item)
#use item in slot(slot)
#use key
#use NPC (who)
#use shop (shop)
#variable (name)
#vehicle A
#vehicle B
#vert flip sprite (handle, flip)
#wait (ticks)
#wait for all
#wait for camera
#wait for key (key)
#wait for NPC (who)
#wait for scancode (key)
#wait for slice (handle)
#wait for text box
#walk NPC (who, direction, distance)
#walk NPC to X (who, X)
#walk NPC to Y (who, Y)
#west
#west wall
#while(condition) do(commands)
#wrap
#write color (index, element, value)
#write enemy data (enemyid, data, value)
#write global (id,value)
#write map block (x,y,value,layer)
#write pass block (x,y,value)
#write zone (zone id, x, y, value)
#x axis
#value,xor,value
#y axis
#Y sort children (handle)
#zero
#zone at spot (x, y, count)
#zone number of tiles (zone id)
#add enemy to formation (formation, enemy id, x, y, slot)

########################################################################
### INTERACTIVE COMMANDS THAT THIS SCRIPT MAKES NO ATTEMPT TO TEST
#
#equip menu (who)
#items menu
#load menu (reallyload)
#main menu
#pick hero
#rename hero(who)
#rename hero by slot(who)
#set full hero swap mode (state)
