########################################################################
# This file contains testcases for the script interpreter and HSpeak.
# It is part of autotest.rpg; see autotest.hss
#

# include a file with UTF-16 encoding
include, "utf16 encoding test.hss"

########################################################################

script, interpreter tests, begin
  hspeak tests
  string tests
  math tests
  scheduling tests
end

########################################################################

script, elseif A, x, begin
  if(x == 0) then( return(1) )
  elseif(x == 1) then( return(2) )
  else( return(3) )
end

script, elseif B, x, begin
  if(x == 0)
  elseif(x == 1) then( return(2) )
end

script, elseif C, x, begin
  if(x == 0)
  elseif(x == 1)
  else( return(3) )
end

script, elseif tests, begin
  $0="elseif tests"
  assert(elseif A(0) == 1)
  assert(elseif A(1) == 2)
  assert(elseif A(2) == 3)
  assert(elseif B(0) == 0)
  assert(elseif B(1) == 2)
  assert(elseif B(2) == 0)
  assert(elseif C(0) == 0)
  assert(elseif C(1) == 0)
  assert(elseif C(2) == 3)
end

########################################################################

script, switch A, x, begin
  return(1)
  switch (x) do(
    case(5) do()
    case(zero)
    case(2) return(100)
            return(101)
    case(7) return(-1)
            while(1) do(continue(2))
            return(-1)
    case(1) return(102)
    case(3, 4, 2)
            return(103)
            break
            return(104)
    case(6, else)
      return(99) 
  )
end

script, switch B, x, begin
  return(1)
  switch(x) do(
    case(5) do()
    case(2) do(
      return(100)
      break
      return(101)
    )
    case(1) return(102)
    case((2+1), 2*2, zero)
      if(x) then(return(103))
      else(return(104))
    else(return(99))
  )
end

script, switch tests, begin
  $0="switch tests"
  assert(switch A(0) == 101)
  assert(switch A(1) == 102)
  assert(switch A(2) == 101)
  assert(switch A(3) == 103)
  assert(switch A(4) == 103)
  assert(switch A(5) == 1)
  assert(switch A(6) == 99)
  assert(switch A(7) == 102)
  assert(switch A(8) == 99)

  assert(switch B(0) == 104)
  assert(switch B(1) == 102)
  assert(switch B(2) == 100)
  assert(switch B(3) == 103)
  assert(switch B(4) == 103)
  assert(switch B(5) == 1)
  assert(switch B(6) == 99)
end

########################################################################

plotscript, ¿ƒüñÑÿ sÇ®¡ÞΤ ηªɱE, begin
  return (42)
end 

# This really doesn't belong here, but I'm too lazy to find a better place
script, hspeak tests, begin
  $0="hspeak tests"
  variable (Über)
  Über := 12
  for (über, über, über + 4) do ()
  assert(Über == 17)

  # Lowercase form in Latin-1, uppercase not
  variable (Ÿve)
  ÿve := 0

  assert(¿ƒüñÑÿ sÇ®¡ÞΤ ηªɱE == 42)

  assert(that script in the other file == 91)
  
  global 5000 := 99999
  assert(global 5000 == 99999)

  elseif tests
  switch tests
end

########################################################################

script, math tests, begin
  variable(n)
  n := 10
  $0="math tests"
  if(abs(-10) <> n) then(crash)
  if(abs(15) <> n + 5) then(crash)
end

########################################################################

# Test the interaction of different script fibres, including pausing,
# waiting, and back-compat blocking.
# This makes use of timers, but the real timer tests are in autotest.hss
script, scheduling tests, begin
  $0="scheduling tests"

  tick counter slice := create container
  set slice velocity x(tick counter slice, 1, 1000)

  blocking tests
  assert(check bug 430 enabled == false)

  free slice(tick counter slice)
end

script, ticknumber, begin
  return(slice x(tick counter slice))
end

########################################################################

script, blocker script, begin
#  assert(ticker 0 == expected ticker 0)
  ticker 1 += 1
  wait
  ticker 1 += 1
end

script, blocker script 2, begin
  assert(ticker 1 == expected ticker 1)
  ticker 2 += 1
  wait
  ticker 2 += 1
  assert(ticker 1 == expected ticker 1)
end

script, eachtick script, begin
  ticker 0 += 1
  set timer(3, 0, 1, @eachtick script)
end

script, blocking tests, begin
  $0="blocking tests"

  variable (start tick)
  start tick := ticknumber
  ticker 0 := 0
  ticker 1 := 0  # globals
  ticker 2 := 0

  # Start an each-tick script on a timer that should not interfer with anything else
  # (since it has a higher timer ID)
  set timer(3, 0, 1, @eachtick script)

  wait(2)
  assert(ticknumber == start tick + 2)

  # Trigger another script and check that this one is blocked
  # (This is also a test for bug 430, because of eachtick script)
  expected ticker 0 := 0
  set timer(1, 0, 1, @blocker script)
  assert(ticknumber == start tick + 2)
  # This script will continue running until the next tick
  assert(ticker 1 == 0)
  wait(1)
  assert(ticker 1 == 2)
  assert(ticknumber == start tick + 4)

  # Trigger two scripts to run at once; one blocks the other (test for bug 430)
  expected ticker 1 := 2
  set timer(1, 0, 1, @blocker script)
  set timer(2, 0, 1, @blocker script 2)  # Runs first
  assert(ticknumber == start tick + 4)
  wait
  assert(ticknumber == start tick + 7)  # one tick wait each plus the wait above
  assert(ticker 1 == 4)
  assert(ticker 2 == 2)

  # Check eachtick ran every tick
  trace value(ticknumber, start tick, ticker 0, ticker 1, ticker 2)
  assert(ticker 0 == ticknumber -- start tick)
  stop timer(2)
end

########################################################################

script, bug 430 tester, begin
  variable (start tick)
  start tick := ticknumber
  wait  # should be skipped
  if (ticknumber == start tick) then (
    # was skipped
    ticker 1 += 1
  )
end

# blocking tests is completely broken if bug 430 is enabled, so here is a separate test,
# Returns whether bug 430 is enabled
script, check bug 430 enabled, begin
  variable (start tick)
  start tick := ticknumber
  ticker 1 := 0  # globals
  ticker 2 := 0

  # Trigger two scripts to run at once; one blocks the other (test for bug 430)
  expected ticker 1 := 0
  set timer(1, 0, 1, @bug 430 tester)
  set timer(2, 0, 1, @blocker script 2)  # Runs first
  wait
  assert(ticker 2 == 2)
  # wait in blocker script 2 plus the wait above
  if(ticknumber == start tick + 2 && ticker 1 == 1) then (
    return (true)
  ) else if(ticknumber == start tick + 3 && ticker 1 == 0) then (
    return (false)
  ) else (
    # Other combinations should be impossible
    crash
  )
end


########################################################################
