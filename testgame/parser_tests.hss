## Automated HSpeak tests. See documentation in hspeaktest.py
## Run these tests with "scons hspeaktest -j4"

## Including just this is faster than all of plotscr.hsd
include, hamsterspeak.hsd

define function, begin
  1,noop4,4,0,0,0,0
end

globalvariable(1,globalvar)
defineconstant(1,constant)

## Check for errors given extra commas, and for operators in illegal positions
script, comma tests, begin
  variable(xx)
  +,                     # ERROR
  + ,                    # ERROR
  <<,                    # ERROR
  << ,                   # ERROR
  ,<<1                   # ERROR
  , <<2                  # ERROR
  ,<3                    # ERROR
  , <4                   # ERROR
  1,-2                   # WARN
  ,-2                    # WARN
  -2,                    # WARN
  noop4(1,-2)            # OK
  1,:=2                  # ERROR
  1,--2                  # ERROR
  2--1                   # WARN
  ## FIXME: This is major lexer bug
  2-1                    # ERROR
  noop4(1,mod,2)         # OK
  #if,(xx) then()         # WARN
  if(xx), then()         # OK
  #if(xx) then,()         # WARN
  noop4((1), (2))        # OK
  noop4(-2)              # OK
  noop4((2) -- (1))      # OK
  ## These error checks aren't implemented; they're hard to catch
  noop(),                # ERROR
  noop,()                # ERROR
  noop4(noop,())         # ERROR
  ## This fails because parsed as noop(0), but noop takes no args
  ## Let's say this should be a warning, because the behaviour would have changed
  noop4(noop,(0))        # WARN
  noop4( --2)            # ERROR
  noop4(,--2)            # ERROR
  noop4( ,  , 0)         # ERROR
  noop4( , 0)            # ERROR
  ## This probably doesn't particularly need to be disallowed
  noop4(0 ,)             # OK
  ## $ is treated as a unary operator
  $,0=""                 # ERROR
  $0,=""                 # ERROR
  $0=,""                 # ERROR
  noop4($0="")           # OK
  noop4(1,$0="")         # OK
  noop4(,$0="")          # ERROR
end

end                      # ERROR
begin                    # ERROR
script, foo, end         # ERROR
()                       # ERROR

script, string tests, begin
  $0="", 232             # WARN
  $0="" 232              # ERROR
  "asdasd"               # ERROR
end

script, number tests, x, begin
  x := 000 0000              # OK
  x := - 14                  # OK
  x := -                     # ERROR
  ## tab characters
  x := -	1	4    # OK
  x := 14a                   # ERROR
  x := - 14a                 # ERROR
  x := 0x14a                 # OK
  x := - 0x 14a              # OK
  x := -	0x	14a  # OK
  x := 0x                    # ERROR
  x := 0o                    # ERROR
  x := 0b                    # ERROR
  ## Space after the 0 not supported... but we don't care one way or the other
  ##x := 0 x1
  ## Numbers which aren't 32 bit
  x := 0x100000000           # ERROR
  x := 0o1                   # OK
  x := 0o8                   # ERROR
  x := 0oa                   # ERROR
  x := 0b0                   # OK
  x := 0xa                   # OK
  x := 0xf                   # OK
  x := 0bf                   # ERROR
  x := 0XF                   # OK
  x := -0x111                # OK
  ## special rules for non-decimals: silently overflow large unsigned 32bit ints
  x := 0xffffffff            # OK
  x := -0xffffffff           # OK
  x := -2147483648           # OK
  x := -2147483649           # ERROR
  x := 1.                    # ERROR
  x := 1.0                   # ERROR
  x := .0                    # ERROR
end

script, math warnings, x, begin
  x := random ()             # ERROR
  x := random (1)            # ERROR
  x := random (1, 0)         # WARNING
  x := random (1, 1)         # OK
  ## The following test optimisations
  x := 1 / 0                 # ERROR
  x := 1, mod, 0             # ERROR
  x := 1^0                   # OK
  x := 0^-1                  # ERROR
  ## Negative exponents evaluate to 0, but will probably change in future
  x := 1^-1                  # OK
  x := sqrt(0)               # OK
  x := sqrt(-1)              # ERROR
end

script, flow tests, dummy, begin
  if(dummy) then() else()
  else()                 # ERROR
  then()                 # ERROR
  break                  # ERROR
  continue               # ERROR
  if () then()           # ERROR
  if(dummy,dummy) then() # ERROR
  if(dummy) if(dummy) then() # ERROR
  if(dummy) else()           # OK
  if(dummy) else() then()    # ERROR
end

script, namespace tests, arg, begin
  variable(noop)         # ERROR
  variable(script)       # ERROR
  variable(globalvar)    # ERROR
  variable(constant)     # ERROR
  variable(flow tests)   # ERROR
  variable(arg)          # ERROR
  variable(1)            # ERROR
  variable(a.)           # ERROR
  variable(v)
  ## subscript args and variables can shadow outer locals, but not globals
  subscript, sub ()                               # OK
  subscript, sub, globalvar ()                    # ERROR
  subscript, sub, constant ()                     # ERROR
  subscript, sub, NO OP ()                        # ERROR
  subscript, sub, namespace tests ()              # ERROR
  subscript, sub, sub ()                          # ERROR
  subscript, sub, arg ()                          # OK
  subscript, sub, v ()                            # OK
  subscript, namespace tests, arg ()              # ERROR
  subscript, sub, (subscript, sub2 ())            # OK
  subscript, sub, (subscript, SUB ())             # ERROR
  subscript, sub, (subscript, namespace tests ()) # ERROR
  subscript, sub, v (subscript, sub2, v ())       # OK
  subscript, sub, W (subscript, sub2, w ())       # OK
end
