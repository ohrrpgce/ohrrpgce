#!/usr/bin/env python3
"""
An rpgbatch example.
Reads a gamedata.bin file generated by scangames.py, and
then prints some info about garbage or use of high gen() indices.
"""
import sys
import time
import pickle
import os
import glob
import numpy as np
from nohrio.ohrrpgce import *
from nohrio.dtypes import dt
from nohrio.wrappers import OhrData

if __name__ == '__main__':
    if len(sys.argv) < 2:
        sys.exit("Expected pickled file")
    pickled = sys.argv[1]
else:
    pickled = 'gamedata.bin'

with open(pickled, 'rb') as f:
    d = pickle.load(f)

rpgidx = d['rpgidx']
gen = d['gen']
mas = d['mas']
fnt = d['fnt']
fixbits = d['fixbits']
del d

# END OF BOILERPLATE

# And now a bunch of sample code....


# Lets find the minimum and maximum value of each field in gen, as a way to detect garbage.

# First we need to cast the record type to an array of 500 INTs so that numpy
# treats it as numerical data

gen_array = gen.view((INT, 500))
gen_min = gen_array.min(axis=0) #.view(dt['gen'])
gen_max = gen_array.max(axis=0) #.view(dt['gen'])

# Lets see where those min/max are attained...
# (Note we can't append .view(dt['gen']) because these are arrays of 32(or native?) bit ints)
gen_argmin = gen_array.argmin(axis=0)
gen_argmax = gen_array.argmax(axis=0)

# Mask out garbage in gen() according to fixWipeGen
need_wipe_gen = np.zeros(len(gen), dtype=bool)
for idx, fixes in enumerate(fixbits):
    if fixes is None:
        need_wipe_gen[idx] = True
    else:
        need_wipe_gen[idx] = (fixes.wipegen == False)
gen_array[need_wipe_gen, 199:] = 0


if __name__ == '__main__':

    # Print out minimum and maximum values of gen entries: checking for unexpected garbage

    for offset in range(500):
        best = [-1, '']
        for field in gen.dtype.names:
            type, foffset = gen.dtype.fields[field]
            foffset //= 2  # from bytes to array index
            if offset == foffset and type.itemsize == 2:
                fieldname = field
                #if gen_min[field] != 0:
                #    print "   min in", rpgidx[gen_argmin[offset]].name
                #print "   max in", rpgidx[gen_argmax[offset]].name
                break
            if foffset <= offset and foffset > best[0]:
                best = [foffset, field]
        else:
            fieldname = '%s[%d]' % (best[1], offset - best[0])
        print("%3d: gen.%-19s min=%d max=%d" % (offset, fieldname, gen_min[offset], gen_max[offset]))
            
    print()
    gen_min = gen_min.view(dt['gen'])
    gen_max = gen_max.view(dt['gen'])

    for field in gen.dtype.names:
        if field.startswith('max'):
            type, offset = gen.dtype.fields[field]
            offset //= 2  # from bytes to array index
            print("max(gen.%s)=%d attained in" % (field, gen_max[field]))
            print("  ", rpgidx[gen_argmax[offset]].name)

    print()

    # Print the indices of games which use some features

    print("Indices of games which have...")
    print("...fixWipeGen set:", np.nonzero(1 - need_wipe_gen_array))
    print("...nonstandard resolution:", np.nonzero(gen_array[:, 194]))  #genResolutionX
    print("...nonstandard windowsize:", np.nonzero(gen_array[:, 208]))  #genWindowSize
    print("...debugmode on:", np.nonzero(gen_array[:, 204]))            #genDebugMode
    print("...currentdebugmode on:", np.nonzero(gen_array[:, 205]))     #genCurrentDebugMode
